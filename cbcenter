#!/bin/bash

# ----------- VIEWER ------------
VIEWER="imv -fd" # <<== I'm here!

# ---------- NAMES -----------
mybasename="$(basename "$0")"
PROJECT="cbcenter"

#
# When using directory variables remember to add a trailing slash.
# For that reason, PDIR stands for (P)artial (DIR)ectory.
#
# ---------- FILES AND DIRECTORIES -----------
MYPATH="${HOME}/.local/$PROJECT"
DOWNLOADS_PDIR="${MYPATH}/downloads"
FAVORITES_PDIR="${MYPATH}/favorites"
FAVORITES_FILE="${FAVORITES_PDIR}.cb"
STREAMS_PDIR="${DOWNLOADS_PDIR}/streams"
CAPTURES_PDIR="${DOWNLOADS_PDIR}/captures"
# ----------- FORMATS ---------------
VIDEO_FORMAT="mp4"
IMG_FORMAT="jpg"
CODEC="h264"
# ----------- TEMP FILES AND DIRECTORIES -------------
TMP_PDIR="/tmp/$PROJECT"
SEARCH_FILE="${TMP_PDIR}/search.cb"
OTHERS_PDIR="${TMP_PDIR}/others"
OTHERS_FILE="${OTHERS_PDIR}.cb"
BIOCONTEXT_FILE="${TMP_PDIR}/biocontext.cb"
MORE_PDIR="${TMP_PDIR}/more"
MORE_FILE="${MORE_PDIR}.cb"
RANDOM_FILE="${TMP_PDIR}/random.cb"

#
# When using url variables remember to add a trailing slash (only when necessary).
# For that reason, PURL stands for (P)artial (URL).
#
# ------------ URLS -------------
PREVIEW_PURL="https://thumb.live.mmcdn.com/riw"
SEARCH_PURL="https://chaturbate.com/ax/search/?keywords=" # not necessary trailing slash
ROOMLIST_PURL="https://chaturbate.com/api/ts/roomlist/room-list"
BIOCONTEXT_PURL="https://chaturbate.com/api/biocontext"
MORE_PURL="https://chaturbate.com/api/more_like"

# ------------ REGULAR EXPRESSIONS -------------
FEMALE_ROOM="f"
MALE_ROOM="m"
COUPLE_ROOM="c"
TRANS_ROOM="t"
ID_REGEX="^[0-9]+$"
CB_ROOT_PURL="https://www.chaturbate.com"
CAM_ROOT_REGEX="https:\/\/edge[0-9]+-[a-z]+\.live\.mmcdn\.com"
LIVE_PREFIX="live-"
LIVE_REGEX="${LIVE_PREFIX}(hls|edge)"
USER_PREFIX="amlst:"
USER_REGEX="[A-Za-z0-9_]{3,30}"
USER_SUFFIX="-sd-"
CODE64="[0-9a-z]{64}"
CODE64_SUFFIX="_trns_"
PLAYLIST="playlist.m3u8"
LIVE_USER_REGEX="${LIVE_REGEX}\/${USER_PREFIX}${USER_REGEX}"
EXTRA_STUFF_REGEX="${USER_SUFFIX}${CODE64}${CODE64_SUFFIX}${CODEC}"
LOCATION_REGEX="${LIVE_USER_REGEX}${EXTRA_STUFF_REGEX}"
MINIMAL_CAM_REGEX="${CAM_ROOT_REGEX}\/${LIVE_USER_REGEX}"
COMPLETE_CAM_REGEX="${MINIMAL_CAM_REGEX}${EXTRA_STUFF_REGEX}\/${PLAYLIST}"
CHUNK_REGEX="chunklist_w[0-9]+_b[0-9]+_t[0-9a-zA-Z=]+\.m3u8"
PROG_REGEX="BANDWIDTH=[0-9]+,NAME=\"FPS:[0-9]+\.[0-9]+\",CODECS=\"[a-z0-9.,]*\",RESOLUTION=[0-9]+x[0-9]+"
ROOM_REGEX="^${USER_REGEX}$"
GENDER_REGEX="${FEMALE_ROOM}|${MALE_ROOM}|${COUPLE_ROOM}|${TRANS_ROOM}"
ROOM_RANGE_REGEX="^(($GENDER_REGEX):[0-9]{0,2}:[0-9]{1,2})$"

# ----------- TOOLS ------------
JQ_ONLINE=".online"
JQ_OFFLINE=".offline"
JQ_HASGTAGS=".hashtags"
XRW_HEADER="X-Requested-With: XMLHttpRequest"
HTTP_NOT_FOUND_TEXT="404 Not Found"
HTTP_TOO_MANY_REQUESTS_TEXT="429 Too Many Requests"
CONNECT_TIMEOUT=10
FETCH_STEPS=10

# ----------- EXIT CODES -----------
OK_CODE=0
INVALID_USERNAME=1
OFFLINE_ROOM=2
UNKNOWN_ERROR=3
PLAYLIST_NOT_FOUND=4
CHUNK_NOT_FOUND=5
ROOM_ALREADY_EXIST=6
ROOM_DOESNT_EXIST=7
EMPTY_DATA=8
INVALID_ROOM_RANGE=9
INVALID_PROG_ID=10
INVALID_KEYWORD=11
INVALID_COMMAND=12
HTTP_NOT_FOUND_ERROR=13
HTTP_TOO_MANY_REQUESTS_ERROR=14
BAD_CHOICE=15
ROOM_LIST_ERROR=16
EMPTY_ROOM_LIST=17
BIOCONTEXT_ERROR=19
JQ_ERROR=19
NOT_PUBLIC_ROOM=20
ROOM_NOT_FOUND=21
CURL_ERROR=22
BANNED_ROOM=23
INVALID_VIEWER=24
INVALID_GENDER=25

# ------------ COLORS -------------
RED_FG="\033[0;31m"
GREEN_FG="\033[0;32m"
LIGHT_BLUE_FG="\033[1;34m"
YELLOW_FG="\033[1;33m"
CLEAR_FG="\033[0m"

# Check if a executable if found on PATH
# '$1' executable name
which_check () {
    echo -n "$1: "
    if which "$1" &>/dev/null; then
        echo "OK"
        return $OK_CODE
    else
        echo -e "${RED_FG}NOT FOUND${CLEAR_FG}"
        return $UNKNOWN_ERROR
    fi
}

# Check dependencies and show info on stdout
check_dependencies () {
    which_check curl
    which_check wget
    which_check sed
    which_check jq
    which_check ffmpeg
    which_check ffplay
    echo "Use one of the following image viewers:"
    # If found exact match on the first "word"
    # (continuous characters without spaces) of viewer variable, then show 'using'
    local cd_viewer
    cd_viewer="$(trim_string "$VIEWER")"
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv-x11)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-x11
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv-wayland)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-wayland
    echo "... or use what you want. Execute '$mybasename __set_viewer command'."
}

show_dist_warning () {
    echo -e "${RED_FG}WARNING: Do not distribute the content obtained with this program\n\
without the user's consent.${CLEAR_FG}\n"
}

# Show help block
show_help () {
    echo -e "$PROJECT usage:\nManage your favorite rooms from $CB_ROOT_PURL.\n\n\
  $mybasename COMMAND OPTION\n\nCommands and options:\n\n\
  a, add               username  - Add new room to favorites.\n\
  r, remove          [username]  - Remove room from favorites.\n\
  ff, fetch-favorites            - Fetch previews of favorite rooms.\n\
  vf, view-favorites             - Open fetched previews (favorites).\n\
  ls, list-favorites             - List of favorite rooms.\n\
  fs, favorites-status           - Same as 'list-favorites', plus online or\n\
                                   offline.\n\
  rs, room-status    [username]  - Show room status, i.e. public, private,\n\
                                   hidden, or offline.\n\
  rp, room-programs  [username]  - Show available programs of given room.\n\
  ri, room-info      [username]  - Show basic info.\n\
  rb, room-bio       [username]  - Show biocontext.\n\
  fo, fetch-others   gender:[offset]:limit\n\
                                 - Fetch previews of other rooms.\n\
                                   See 'Fetch ranges' section.\n\
  vo, view-others                - Open fetched previews (others).\n\
  lo, list-others                - List of fetched rooms (others).\n\
  fm, fetch-more     [username]  - Fetch previews of rooms like 'username'.\n\
  vm, view-more                  - Open fetched previews (more).\n\
  lm, list-more                  - List of fetched rooms (more).\n\
  sc, save-capture   [username]  - Save a screenshot (high resolution).\n\
  ss, save-stream    [username]  - Save stream of given room.\n\
  ps, play-stream    [username]  - Play stream of given room.\n\
  ks, keyword-search    keyword  - Search a keyword on the website.\n\
  ra, random           [gender]  - Show preview of random room. If 'gender' is\n\
                                   provided, only fetch 'gender' rooms.\n\
  tn, thumbnail      [username]  - Show preview of given room.\n\
  __clear_favorites              - Clear the 'favorites' directory.\n\
  __clear_captures               - Clear the 'captures' directory.\n\
  __clear_streams                - Clear the 'streams' directory.\n\
  __clear_others                 - Clear the 'others' directory.\n\
  __clear_all\n\
  __set_viewer      command      - Set the 'command' as viewer.\n\
  __check_deps                   - Check program dependencies.\n\
  h, help                        - This text.\n\n\
TIP: If [username] is not provided, you will be asked to choose an option\n\
     from your favorites.\n\nFetch ranges:\n\n\
  gender: Gender of room users.\n\
          'f' (female) or 'm' (male) or 'c' (couple) or 't' (trans)\n\
  offset: Begining room.\n\
          Two digits (max) integer from 0 (or 00) to 99.\n\
          If none is provided, the value 0 is taken.\n\
  limit:  Number of rooms.\n\
          Two digits (max) integer from 1 (or 01) to 99.\n\nDirectories and files:\n\n\
  PROJECT DIR:   $MYPATH/\n\
  DOWNLOADS DIR: $DOWNLOADS_PDIR/\n\
  FAVORITES DIR: $FAVORITES_PDIR/\n\
  FAVORITES:     $FAVORITES_FILE\n\
  TEMPORAL DIR:  $TMP_PDIR/\n\
  MORE DIR:      $MORE_PDIR/\n\
  OTHERS DIR:    $OTHERS_PDIR/\n\
  BIOCONTEXT:    $BIOCONTEXT_FILE\n\
  MORE:          $MORE_FILE\n\
  OTHERS:        $OTHERS_FILE\n\
  RANDOM:        $RANDOM_FILE\n\
  SEARCH:        $SEARCH_FILE\n\nExit codes:\n\n\
  exit code $HTTP_TOO_MANY_REQUESTS_ERROR)\n\
    You are probably being blocked by rate limiting.\n\
    A rate limiting solution measures the amount of time between each\n\
    request from each IP address, and also measures the number of\n\
    requests within a specified timeframe. If there are too many\n\
    requests from a single IP within the given timeframe, the rate\n\
    limiting solution will not fulfill the IP address's requests for a\n\
    certain amount of time.\n\
  exit code $HTTP_NOT_FOUND_ERROR)\n\
    The room does not exist.\n\
  exit code $EMPTY_DATA or $CHUNK_NOT_FOUND)\n\
    Connection error or corrupted data.\n\
  exit code $PLAYLIST_NOT_FOUND)
    If the room is online it could be private or hidden, otherwise it\n\
    is offline. You can use 'room-status' command to see room status, i.e.\n\
    public, private, hidden, or offline.\n\nFAQs:\n\n\
  - What is a 'program ID'?\n\
      A 'program' represent the stream 'channel' or 'quality'. This channels\n\
      are identified by ID, from '0' (lowest quality) to 'n' (highest quality).\n\
      To get cam programs use 'info' command. You can go to FFMPEG Documentation\n\
      for more info.\n\
  - What do the strange errors mean when I want to play/save/capture?\n\
      See 'Exit codes' section.
  - How can I change the default image viewer for previews?\n\
      Just change the 'VIEWER' variable to whatever you want (within the\n\
      executable), or use '__set_viewer' command. See 'Examples' section.\n\
      NOTE: the image viewer must support opening entire directories.\n\
  - Why are the rooms fetched in $FETCH_STEPS at a time?\n\
      To avoid error code $HTTP_TOO_MANY_REQUESTS_ERROR. See 'Exit codes' section.\n\nExamples:\n\n\
  - Fetch the first 10 female rooms:\n\
      $mybasename fetch-others f::10\n\
  - Fetch 30 (couples) rooms starting from 13th:\n\
      $mybasename fetch-others c:13:30\n\
  - Fetch a (random) trans room:\n\
      $mybasename random t\n\
  - Fetch more rooms with a similar appearance and content:\n\
      $mybasename fetch-more userhere\n\
  - Set the image viewer:\n\
      $mybasename __set_viewer gpicview\n\
      $mybasename __set_viewer \"imv-wayland -fd\"\n"
}

# Send error messange and exit program
# '$1' error code
send_exit_error () {
    case "$1" in
        "$INVALID_USERNAME")
            echo "Invalid username !" 1>&2
            exit $INVALID_USERNAME
            ;;
        "$OFFLINE_ROOM")
            echo "The room is offline !" 1>&2
            exit $OFFLINE_ROOM
            ;;
        "$PLAYLIST_NOT_FOUND")
            echo "An error occurred while processing the page ! (PLAYLIST_NOT_FOUND)" 1>&2
            exit $PLAYLIST_NOT_FOUND
            ;;
        "$CHUNK_NOT_FOUND")
            echo "An error occurred while processing room data ! (CHUNK_NOT_FOUND)" 1>&2
            exit $CHUNK_NOT_FOUND
            ;;
        "$ROOM_ALREADY_EXIST")
            echo "The room already exists in the favorites list !" 1>&2
            exit $ROOM_ALREADY_EXIST
            ;;
        "$ROOM_DOESNT_EXIST")
            echo "The room does not exists in the favorites list !" 1>&2
            exit $ROOM_DOESNT_EXIST
            ;;
        "$EMPTY_DATA")
            echo "Error getting room data ! (EMPTY_DATA)" 1>&2
            exit $EMPTY_DATA
            ;;
        "$INVALID_PROG_ID")
            echo "Invalid program ID !" 1>&2
            exit $INVALID_PROG_ID
            ;;
        "$INVALID_KEYWORD")
            echo "Invalid keyword to search !" 1>&2
            exit $INVALID_KEYWORD
            ;;
        "$INVALID_COMMAND")
            echo "Error: invalid command. Use '$mybasename help' for more info." 1>&2
            exit $INVALID_COMMAND
            ;;
        "$HTTP_NOT_FOUND_ERROR")
            echo "Server response: $HTTP_NOT_FOUND_TEXT" 1>&2
            exit $HTTP_NOT_FOUND_ERROR
            ;;
        "$HTTP_TOO_MANY_REQUESTS_ERROR")
            echo "Server response: $HTTP_TOO_MANY_REQUESTS_TEXT" 1>&2
            exit $HTTP_TOO_MANY_REQUESTS_ERROR
            ;;
        "$INVALID_ROOM_RANGE")
            echo -e "Invalid room range !" 1>&2
            exit $INVALID_ROOM_RANGE
            ;;
        "$BAD_CHOICE")
            echo -e "Bad choice !" 1>&2
            exit $BAD_CHOICE
            ;;
        "$ROOM_LIST_ERROR")
            echo -e "Error gettig room list !" 1>&2
            exit $ROOM_LIST_ERROR
            ;;
        "$EMPTY_ROOM_LIST")
            echo -e "Empty room list !" 1>&2
            exit $EMPTY_ROOM_LIST
            ;;
        "$BIOCONTEXT_ERROR")
            echo -e "Error getting biocontext" 1>&2
            exit $BIOCONTEXT_ERROR
            ;;
        "$JQ_ERROR")
            echo -e "An error occurred while processing json data !" 1>&2
            exit $JQ_ERROR
            ;;
        "$NOT_PUBLIC_ROOM")
            echo -e "The room is not public (${2:-private/hidden}) !" 1>&2
            exit $NOT_PUBLIC_ROOM
            ;;
        "$ROOM_NOT_FOUND")
            echo -e "Room not found !" 1>&2
            exit $ROOM_NOT_FOUND
            ;;
        "$CURL_ERROR")
            echo -e "An error occurred while fetching resource !" 1>&2
            exit $CURL_ERROR
            ;;
        "$BANNED_ROOM")
            echo -e "The room is banned from the site !" 1>&2
            exit $BANNED_ROOM
            ;;
        "$INVALID_VIEWER")
            echo -e "Invalid viewer command !" 1>&2
            [[ -n "$2" ]] && echo -e "VIEWER variable contains: '${VIEWER}'\n\
Run '$mybasename __set_viewer command' to set a valid viewer." 1>&2
            exit $INVALID_VIEWER
            ;;
        "$INVALID_GENDER")
            echo -e "Invalid gender !" 1>&2
            exit $INVALID_GENDER
            ;;
        *)
            echo "UNKNOWN_ERROR" 1>&2
            exit $UNKNOWN_ERROR
            ;;
    esac
}

# Wrap username using CB_ROOT_PURL
# '$1' username
wrap_username () {
    echo "${CB_ROOT_PURL}/$1/"
}

# Show search response on stdout
# '$1' keyword
curl_search () {
    curl -sL --compressed -H "$XRW_HEADER" "${SEARCH_PURL}$1"
}

# return 0 if online/private/hidden, else 1 (offline)
# '$1' username
is_online () {
    curl_search "$1" | jq -Mc $JQ_ONLINE | grep -q "\"$1\""
}

# Store room_status field on '$2' from biocontext file (JSON)
# Also send exit error if the room: doesnt exist or is banned.
# '$1' room
# '$2' store room_status
assert_active_room () {
    [[ -n "$2" ]] && declare -n rs_out="$2"
    fetch_bio "$1"
    rs_out="$(jq -Mr '.room_status' "$BIOCONTEXT_FILE" 2>/dev/null)" ||
        send_exit_error $ROOM_NOT_FOUND
    [[ "$rs_out" == "null" ]] && send_exit_error $BANNED_ROOM
}

# return 0 if valid, else 1
# '$1' id
valid_id () {
    [[ "$1" =~ $ID_REGEX ]]
}

# return 0 if valid, else 1
# '$1' room range
valid_room_range () {
    [[ "$1" =~ $ROOM_RANGE_REGEX ]]
}

# Extract programs from playlist data and show on stdout
# '$1' playlist data
extract_programs () {
    declare -n gp_data="$1"
    declare -i gp_current=0
    while [[ $gp_data =~ $PROG_REGEX ]]; do
        echo -e "\t${YELLOW_FG}PROG_ID=\"$gp_current\"${CLEAR_FG} - ${BASH_REMATCH[0]}"
        gp_data="${gp_data/${BASH_REMATCH[0]}/}"
        gp_current+=1
    done
}

# Get data from playlist and show on stdout
# '$1' room playlist
fetch_data () {
    curl -siL --compressed --connect-timeout "$CONNECT_TIMEOUT" "$1"
}

# Extract playlist from room page
# '$1' username
# '$2' store extracted playlist
extract_playlist () {
    declare -n ep_out="$2"
    local ep_cburl
    ep_cburl="$(wrap_username "$1")"
    local ep_page
    if ! ep_page="$(wget -4 -qS -O - "$ep_cburl" 2>&1)"; then
        [[ "$ep_page" =~ $HTTP_NOT_FOUND_TEXT ]] && send_exit_error $HTTP_NOT_FOUND_ERROR
        [[ "$ep_page" =~ $HTTP_TOO_MANY_REQUESTS_TEXT ]] && send_exit_error $HTTP_TOO_MANY_REQUESTS_ERROR
    fi
    ep_page="$(echo -e "$ep_page")"
    [[ "$ep_page" =~ $COMPLETE_CAM_REGEX ]] || send_exit_error $PLAYLIST_NOT_FOUND
    ep_out="${BASH_REMATCH[0]}"
    [[ -z $ep_out ]] && send_exit_error $UNKNOWN_ERROR
    return $OK_CODE
}

# Extract direct link from playlist. Useful for speedup fetch process of save/capture streams.
# '$1' username
# '$2' store extracted link
extract_direct_link () {
    local dl_link
    extract_playlist "$1" dl_link
    declare -n dl_out="$2"
    local dl_prog="$3"
    local dl_data
    dl_data="$(fetch_data "$dl_link")"
    [[ -z $dl_data ]] && send_exit_error $EMPTY_DATA
    if [[ -z $dl_prog ]]; then
        extract_programs dl_data
        read -rp "Select a program ID: " dl_prog
        valid_id "$dl_prog" || send_exit_error $INVALID_PROG_ID
    fi
    local dl_chunk
    declare -i dl_current=0
    # Extract chunk from data (chunks are .m3u8 files for specific stream quality)
    # If user choice prog id 0, then first chunk is extracted (low quality stream)
    # For high quality stream, pass high prog id (e.g. 99)
    while [[ $dl_data =~ $CHUNK_REGEX ]] && [[ $dl_current -le $dl_prog ]]; do
        dl_chunk="${BASH_REMATCH[0]}"
        # Remove match from data
        dl_data="${dl_data/${BASH_REMATCH[0]}/}"
        dl_current+=1
    done
    [[ -z $dl_chunk ]] && send_exit_error $CHUNK_NOT_FOUND
    local dl_root_locat
    # In some cases stream is located in another place than main playlist (_link)
    if [[ $dl_data =~ $LOCATION_REGEX ]]; then
        # If new location is found, replace it
        dl_root_locat="${dl_link%%"${LIVE_PREFIX}"*}${BASH_REMATCH[0]}"
    else
        # Else keep location and only remove '/playlist.m3u8' from '_link'
        dl_root_locat="${dl_link%/*}"
    fi
    dl_out="${dl_root_locat}/${dl_chunk}"
    [[ -z $dl_out ]] && send_exit_error $UNKNOWN_ERROR
    return $OK_CODE
}

# return 0 if valid, else 1
# '$1' username
valid_username () {
    [[ "$1" =~ $ROOM_REGEX ]]
}

# Show formated date on stdout
formated_date () {
    date +%Y%m%d%H%M%S
}

# return 0 if room exists on favorites file, else 1
# '$1' room
room_exists () {
    grep -qx "$1" "$FAVORITES_FILE"
}

# Get favorite room from FAVORITES_FILE using line number
# '$1' line number
get_favorite_line () {
    sed "${1}q;d" "$FAVORITES_FILE"
}

# Remove line from FAVORITES_FILE
# '$1' line number
rem_favorite_line () {
    sed -i "${1:?Empty parameter !}d" "$FAVORITES_FILE" && echo "Favorite removed!"
}

# Ask the user for a choice, and store the choice on '$1'. If '$2' is other
# than 'hide_list', then show favorites list (with line numbers).
# '$1' store choice
# '$2' hide_list (optional)
favorite_choice () {
    declare -n fc_out="$1"
    [[ $2 == "hide_list" ]] || list_favorites
    read -rp "Type your choice (i.e. the beginning number before the ':'), or (Q)uit: " fc_out
    [[ $fc_out == [qQ] || -z "$fc_out" ]] && exit $OK_CODE
    valid_id "$fc_out" || send_exit_error $BAD_CHOICE
}

# Uses FAVORITES_FILE
# The same as 'favorite_choice' but store username on '$1'.
# '$1' store username
# '$2' hide_list (optional)
favorite_room_choice () {
    declare -n fuc_out="$1"
    local frc_choice
    favorite_choice frc_choice "$2"
    fuc_out="$(get_favorite_line "$frc_choice")"
    [[ -z $fuc_out ]] && send_exit_error $UNKNOWN_ERROR
}

# Get the username from OTHERS_FILE using an index
# '$1' index
get_other_index () {
    jq -Mre ".rooms[${1:?}].username" "$OTHERS_FILE"
}

# Show list of other rooms with line number
list_others () {
    num_rooms="$(jq -e '.rooms | length' "$OTHERS_FILE")" || send_exit_error $JQ_ERROR
    [[ $num_rooms -eq 0 ]] && send_exit_error $EMPTY_ROOM_LIST
    for ((i = 0 ; i < num_rooms ; i++)); do
        echo "$i:$(get_other_index "$i")"
    done
}

# Uses OTHERS_FILE
# Ask the user for a choice, and store the username on '$1'. If '$2' is other
# than 'hide_list', then show favorites list (with line numbers).
# '$1' store username
# '$2' hide_list (optional)
other_room_choice () {
    declare -n orc_out="$1"
    local orc_choice
    [[ $2 == "hide_list" ]] || list_others
    read -rp "Type your choice (i.e. the beginning number before the ':'), or (Q)uit: " orc_choice
    [[ $orc_choice == [qQ] || -z "$orc_choice" ]] && exit $OK_CODE
    valid_id "$orc_choice" || send_exit_error $BAD_CHOICE
    orc_out="$(get_other_index "$orc_choice")"
    [[ -z $orc_out ]] && send_exit_error $UNKNOWN_ERROR
}

# Add new room to favorites
# '$1' room
add_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    room_exists "$1" && send_exit_error $ROOM_ALREADY_EXIST
    local ar_status
    assert_active_room "$1" ar_status
    echo "$1" >> "$FAVORITES_FILE" && echo "Favorite added! The room is $ar_status"
}

# Remove room from favorites
# '$1' room
remove_room () {
    if [[ -z "$1" ]]; then
        local rr_choice
        echo "Which room do you want to delete?"
        favorite_choice rr_choice
        rem_favorite_line "$rr_choice"
        return $OK_CODE
    fi
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    if match="$(grep -xn "$1" "$FAVORITES_FILE")"; then # Exact match
        rem_favorite_line "${match%%:*}"
    else # Search partial matches
        # Use '-n' option on grep to use line numbers as choices if partial matches found
        match="$(grep -n "$1" "$FAVORITES_FILE")"
        [[ -z $match ]] && send_exit_error $ROOM_DOESNT_EXIST
        echo "No exact match found!"
        echo "Which room do you want to delete?"
        echo "$match"
        local rr_choice
        favorite_choice rr_choice hide_list
        # Validate choice
        if echo "$match" | grep -q -E "^($rr_choice:)" -; then
            rem_favorite_line "$rr_choice"
        else
            send_exit_error $BAD_CHOICE
        fi
    fi
}

# Clear favorites directory
clear_favorites_dir () {
    rm -f "${FAVORITES_PDIR:?}"/*
}

# Clear captures directory
clear_captures_dir () {
    rm -f "${CAPTURES_PDIR:?}"/*
}

# Clear streams directory
clear_streams_dir () {
    rm -f "${STREAMS_PDIR:?}"/*
}

# Clear rooms directory
clear_others_dir () {
    rm -f "${OTHERS_PDIR:?}"/*
}

# Get preview and save it in given file
# '$1' username
# '$2' file
save_preview_in () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" -o "$2"
}

# Get preview and save it in given directory with predefined preffix (custom preffix is optional)
# '$1' username
# '$2' directory
# '$3' custom preffix (optional)
save_preview () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" -o "${2}/$3$(formated_date)-$1.$IMG_FORMAT"
}

# Get preview and show it using image viewer (not save file)
show_preview () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" | $VIEWER -
}

# fetch_favorites helper
# save preview of '$1' on FAVORITES_PDIR: if success print 'fetched', else 'error'
# '$1' username
# '$2' line preffix
ff_helper () {
    if valid_username "$1" && is_online "$1"; then
        save_preview "$1" "$FAVORITES_PDIR" && echo "$2:$1 fetched" && return $OK_CODE
        echo -e "$2:$1 ${RED_FG}error${CLEAR_FG}"
        return $UNKNOWN_ERROR
    fi
}

# Get previews of favorites (online only)
fetch_favorites () {
    clear_favorites_dir
    declare -i line=1
    while IFS="" read -r room || [ -n "$room" ]
    do
        ff_helper "$room" "$line" &
        line+=1
    done < "$FAVORITES_FILE"
    wait
    # Ask to show fetched previews
    read -rp "Open previews? (Y/n): " ropen
    [[ $ropen == [yY] || $ropen == [yY][eE][sS] || -z $ropen ]] || return $OK_CODE
    open_favorites_dir
}

ask_to_play () {
    read -rp "Do you want to play '$1' stream? (Y/n): " ropen
    [[ $ropen == [yY] || $ropen == [yY][eE][sS] || -z $ropen ]] || return $OK_CODE
    play_room "$1"
}

# Get and show preview of given room
# '$1' username
quick_thumb () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    show_preview "$1"
    ask_to_play "$1"
}

# Open favorites directory
open_favorites_dir () {
    $VIEWER "$FAVORITES_PDIR"
}

# Make sure the room is public, else exit program with an error
# '$1' room
assert_public_room () {
    local apra_status
    assert_active_room "$1" apra_status
    [[ "$apra_status" == "public" ]] && return $OK_CODE
    [[ "$apra_status" == "offline" ]] && send_exit_error $OFFLINE_ROOM
    #[[ "$apra_status" == "null" ]] && send_exit_error $NOT_PUBLIC_ROOM banned
    send_exit_error $NOT_PUBLIC_ROOM "$apra_status"
}

# Play room stream
# '$1' room
play_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    local pr_link
    extract_playlist "$1" pr_link
    ffplay -i "$pr_link"
}

# Save room stream
# '$1' room
save_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    local sr_link
    extract_direct_link "$1" sr_link
    output="${STREAMS_PDIR}/$(formated_date)-$1.$VIDEO_FORMAT"
    ffmpeg -i "$sr_link" -codec copy "$output"

    # Another way (slower ffmpeg startup)
    #local sr_link
    #extract_playlist "$1" sr_link
    #ffmpeg -i "$sr_link" -map v:p:$room_prog -map a:p:$room_prog -codec copy "$output"
}

# Save room screenshot
# '$1' room
save_capture () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    local sc_link
    extract_direct_link "$1" sc_link 99
    output="${CAPTURES_PDIR}/$(formated_date)-$1.$IMG_FORMAT"
    ffmpeg -i "$sc_link" -frames:v 1 -update true "$output"
}

# Show room programs
# '$1' room
room_programs () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    local rp_link
    extract_playlist "$1" rp_link
    room_data="$(fetch_data "$rp_link")"
    [[ -z $room_data ]] && send_exit_error $EMPTY_DATA
    extract_programs room_data
}

# Search given keyword
# '$1' keyword
keyword_search () {
    valid_username "$1" || send_exit_error $INVALID_KEYWORD
    curl_search "$1" > "$SEARCH_FILE" || send_exit_error $CURL_ERROR
    echo "Online rooms:"
    jq "$JQ_ONLINE" "$SEARCH_FILE"
    echo "Recently online rooms:"
    jq -M "$JQ_OFFLINE" "$SEARCH_FILE"
    echo "Hashtags:"
    jq -M "$JQ_HASGTAGS" "$SEARCH_FILE"
}

# Show status of given room
# '$1' room
show_online_offline () {
    if is_online "$1"; then
        echo -e "$1 is ${LIGHT_BLUE_FG}online${CLEAR_FG}"
    else
        echo "$1 is offline"
    fi
}

# Show favorites status
# Only show online or offline (not the same as 'intern_status' function)
global_status () {
    while IFS="" read -r room || [ -n "$room" ]
    do
        valid_username "$room" && show_online_offline "$room" &
    done < "$FAVORITES_FILE"
    wait
}

# Show favorites on stdout
list_favorites () {
    declare -i line=1
    while IFS="" read -r room || [ -n "$room" ]
    do
        echo "$line:$room"
        line+=1
    done < "$FAVORITES_FILE"
}

# Open others directory
open_others_dir () {
    $VIEWER "$OTHERS_PDIR"
}

# Save rooms list from given range on '$4' file.
# '$1' gender
# '$2' offset
# '$3' limit
# '$4' output
fetch_roomlist_file () {
    curl -sL --compressed -H "$XRW_HEADER" "$ROOMLIST_PURL/?genders=$1&offset=$2&limit=$3&enable_recommendations=false" -o "$4"
}

# fetch_rooms_helper helper
# save preview of '$1' on '$3': if success print 'fetched', else 'error'
# '$1' username
# '$2' index preffix
# '$3' dest dir
frh_helper () {
    [[ $2 -lt 10 ]] && preffix="0$2" || preffix="$2"
    save_preview "$1" "$3" "$preffix" && echo "$2:$1 fetched" && return $OK_CODE
    echo -e "$2: $1 ${RED_FG}error${CLEAR_FG}"
    return $UNKNOWN_ERROR
}

# This abstract function avoids duplicate code.
# But it is probably easier to understand by dividing this function for each
# particular case (room-list and more-list).
# 'room-list' is obtained with fetch_roomlist_file
# 'more-list' is obtained with fetch_morelist_file
# Takes a 'room-list' or 'more-list' from '${1}' file and fetch all.
# Files of type 'room-list' and 'more-list' have a main array called 'rooms'.
# If in the future this does not happen, you must add a parameter for
# that attribute. i.e. '$x' for array
# '$1' name of json file. Is used to extract PDIR taking into account
#      that: e.g. OTHERS_FILE="${OTHERS_PDIR}.cb"
# '$2' json field inside main array 'rooms' (e.g. it could be username or room)
# '$3' function name to clear dir
# '$4' function name to open dir
fetch_rooms_helper () {
    local frh_file="$1"
    local frh_field="$2"
    local frh_clear="$3"
    local frh_open="$4"
    declare -i num_rooms
    num_rooms="$(jq -e '.rooms | length' "$frh_file")" || send_exit_error $JQ_ERROR
    [[ $num_rooms -eq 0 ]] && send_exit_error $EMPTY_ROOM_LIST
    echo -e "${YELLOW_FG}TIP:${CLEAR_FG} Go back in the image viewer to see the most recent ones."
    $frh_clear

    # Implementation to go crazy (without stops)
    # for ((i = 0 ; i < num_rooms ; i++)); do
    #     room="$(jq -Mr ".rooms[$i].$frh_field" "$frh_file")"
    #     frh_helper "$room" "$i" "${frh_file%.*}" &
    # done
    # wait
    # read -rp "Open previews? (Y/n): " ropen
    # [[ $ropen == [yY] || $ropen == [yY][eE][sS] || -z $ropen ]] && $frh_open

    # Implementation with stops (FETCH_STEPS at a time)
    declare -i index=0
    local room
    while true; do
        # Fetch room previews by 'FETCH_STEPS' at time
        while room="$(jq -Mre ".rooms[$index].$frh_field" "$frh_file")"; do
            frh_helper "$room" "$index" "${frh_file%.*}" &
            index+=1
            [[ $((index%FETCH_STEPS)) -ne 0 ]] || break
        done
        wait
        read -rp "Open previews? (Y/n): " ropen
        [[ $ropen == [yY] || $ropen == [yY][eE][sS] || -z $ropen ]] && $frh_open
        [[ $index -eq $num_rooms ]] && break # There are no remaining rooms
        read -rp "Continue fetching? $((num_rooms-index)) remaining (Y/n): " rcont
        [[ $rcont == [yY] || $rcont == [yY][eE][sS] || -z $rcont ]] || break
    done
}

# Get and show rooms from given range
# '$1' range
fetch_other_rooms () {
    valid_room_range "$1" || send_exit_error $INVALID_ROOM_RANGE
    local gender
    # Extract gender
    gender="${1%%:*}"
    local offset
    # Extract offset
    offset="${1#*:}"
    offset="${offset%:*}"
    [[ -z $offset ]] && offset=0
    # If offset contains 2 digits, remove 0 from beginning if exist. (09 -> 9)
    [[ ${#offset} -ne 1 ]] && offset="${offset#0}"
    local limit
    # Extract limit
    limit="${1##*:}"
    [[ ${#limit} -ne 1 ]] && limit="${limit#0}"
    [[ $limit -eq 0 ]] && send_exit_error $INVALID_ROOM_RANGE

    echo "Fetching $gender rooms from $offset to $((offset+limit-1)) ..."
    echo -e "${GREEN_FG}INFO:${CLEAR_FG} Sometimes promoted rooms appear. For this reason, it is possible\n\
that more than $limit rooms will be obtained."

    fetch_roomlist_file "$gender" "$offset" "$limit" "$OTHERS_FILE" || send_exit_error $ROOM_LIST_ERROR
    fetch_rooms_helper "$OTHERS_FILE" "username" clear_others_dir open_others_dir
}

# Save biocontext of given room
# '$1' room
fetch_bio () {
    curl -sL --compressed -H "$XRW_HEADER" "${BIOCONTEXT_PURL}/$1" -o "$BIOCONTEXT_FILE" || send_exit_error $BIOCONTEXT_ERROR
}

# Show basic info using biocontext
# '$1' room
room_info () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_active_room "$1" # it calls fetch_bio
    echo -n "Real name: "
    jq -M '.real_name' "$BIOCONTEXT_FILE" 2>/dev/null || send_exit_error $ROOM_NOT_FOUND
    echo -n "Location: "
    jq -M '.location' "$BIOCONTEXT_FILE"
    echo -n "Sex: "
    jq -M '.sex' "$BIOCONTEXT_FILE"
    echo -n "Age: "
    jq -M '.display_age' "$BIOCONTEXT_FILE"
    echo -n "Languages: "
    jq -M '.languages' "$BIOCONTEXT_FILE"
    echo -n "Room status: "
    jq -M '.room_status' "$BIOCONTEXT_FILE"
    echo -n "Last stream: "
    jq -M '.time_since_last_broadcast' "$BIOCONTEXT_FILE"
}

# Show biocontext
# '$1' room
room_bio () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_active_room "$1" # it calls fetch_bio
    jq . "$BIOCONTEXT_FILE" 2>/dev/null || send_exit_error $ROOM_NOT_FOUND
}

# 0 if '$1' is a valid 'gender' on the site, else 1
valid_gender () {
    [[ "$1" =~ ^($GENDER_REGEX)$ ]]
}

# Show random preview using a custom range ('$1':RANDOM:1 or RANDOM:RANDOM:1 if '$1' is empty)
# '$1' gender
quick_rand () {
    local gender="$1"
    [[ -n "$gender" ]] && ! valid_gender "$gender" && send_exit_error $INVALID_GENDER
    [[ -z "$gender" ]] && case $((RANDOM%4)) in
        0) gender=f
            ;;
        1) gender=m
            ;;
        2) gender=c
            ;;
        3) gender=t
            ;;
    esac
    fetch_roomlist_file "$gender" $((RANDOM%100)) 1 "$RANDOM_FILE" || send_exit_error $ROOM_LIST_ERROR
    room="$(jq -Mre ".rooms[0].username" "$RANDOM_FILE")" || send_exit_error $JQ_ERROR
    show_preview "$room"
    echo "Fetched $room room ($gender). Enjoy!"
    ask_to_play "$room"
}

# Remove leading and trailing spaces
# '$1' string var
trim_string() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo "$var"
}

# Verify that '$1' only contains letters, numbers, spaces, and '/' '.' '_' '-' symbols
# '$1' command string
valid_command_string () {
    [[ "$1" =~ ^[a-zA-Z0-9\ \/\._-]+$ ]]
}

# Set the image viewer command
# '$1' image viewer
set_viewer () {
    valid_command_string "$1" || send_exit_error $INVALID_VIEWER
    echo "Setting image viewer ..."
    # Verify if it is on PATH
    if ! which_check "${1%% *}"; then
        echo "... but not found on PATH"
        read -rp "Set anyway? (Y/n): " choice
        [[ $choice == [yY] || $choice == [yY][eE][sS] || -z $choice ]] || return $OK_CODE
    fi
    # Escape slashes with backslashes: ${1//\//\\\/} (the first two slashes means 'replace all')
    sed -i --follow-symlinks "s/VIEWER=\".*\"/VIEWER=\"${1//\//\\\/}\"/" "$0"
    echo "Now you are using '$1'"
}

# Show room status (public/private/hidden/offline)
intern_status () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    local is_status
    assert_active_room "$1" is_status
    echo "$is_status"
}

# Discard invalid usernames from FAVORITES_FILE
check_favorites () {
    while IFS='' read -r rline; do
        valid_username "$rline" && echo "$rline"
    done < "$FAVORITES_FILE" > "${FAVORITES_FILE}.checked"
    mv "${FAVORITES_FILE}.checked" "$FAVORITES_FILE"
}

# Open previews on MORE_PDIR
open_more_dir () {
    $VIEWER "$MORE_PDIR"
}

# Remove previews on MORE_PDIR
clear_more_dir () {
    rm -f "${MORE_PDIR:?}"/*
}

# Fetch rooms list similar to '$1' and save on $MORE_FILE
# '$1' room
fetch_morelist_file () {
    curl -sL --compressed -H "$XRW_HEADER" "${MORE_PURL}/$1" -o "$MORE_FILE"
}

# Fetch and show rooms similar to '$1'
# '$1' username
fetch_more_rooms () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_active_room "$1"
    fetch_morelist_file "$1" || send_exit_error $ROOM_LIST_ERROR
    echo "$1" > "${MORE_FILE}.who"
    fetch_rooms_helper "$MORE_FILE" "room" clear_more_dir open_more_dir
}

assert_more_who () {
    [[ -e "${MORE_FILE}.who" ]] || send_exit_error $UNKNOWN_ERROR
}

show_dist_warning

command="$1"
[[ -n "$command" ]] && command="$(trim_string "$command")"
if [[ "$command" == "h" || "$command" == "help" ]]; then
    show_help
    exit $OK_CODE
fi

# Make directories
#[[ -d "$MYPATH" ]] || mkdir -p "$MYPATH"
[[ -d "$DOWNLOADS_PDIR" ]] || mkdir -p "$DOWNLOADS_PDIR"
[[ -d "$STREAMS_PDIR" ]] || mkdir -p "$STREAMS_PDIR"
[[ -d "$CAPTURES_PDIR" ]] || mkdir -p "$CAPTURES_PDIR"
[[ -d "$FAVORITES_PDIR" ]] || mkdir -p "$FAVORITES_PDIR"
[[ -d "$OTHERS_PDIR" ]] || mkdir -p "$OTHERS_PDIR"
[[ -d "$MORE_PDIR" ]] || mkdir -p "$MORE_PDIR"
[[ -e "$FAVORITES_FILE" ]] || touch "$FAVORITES_FILE"

check_favorites
valid_command_string "$VIEWER" || send_exit_error $INVALID_VIEWER "$VIEWER"

param="$2"
[[ -n "$param" ]] && param="$(trim_string "$param")"

# Main switch
case "$command" in
    a|add)
        add_room "$param"
        ;;
    r|remove)
        remove_room "$param"
        ;;
    ff|fetch-favorites)
        fetch_favorites
        ff_choice=""
        echo "Which room do you want to play?"
        favorite_room_choice ff_choice hide_list
        play_room "$ff_choice"
        ;;
    vf|view-favorites)
        open_favorites_dir
        ofd_choice=""
        echo "Which room do you want to play?"
        favorite_room_choice ofd_choice
        play_room "$ofd_choice"
        ;;
    lf|list-favorites)
        list_favorites
        ;;
    fs|favorites-status)
        global_status
        ;;
    rs|room-status)
        [[ -z $param ]] && favorite_room_choice param
        intern_status "$param"
        ;;
    rp|room-programs)
        [[ -z $param ]] && favorite_room_choice param
        room_programs "$param"
        ;;
    ri|room-info)
        [[ -z $param ]] && favorite_room_choice param
        room_info "$param"
        ;;
    rb|room-bio)
        [[ -z $param ]] && favorite_room_choice param
        room_bio "$param"
        ;;
    fo|fetch-others)
        fetch_other_rooms "$param"
        for_choice=""
        echo "Which room do you want to play?"
        other_room_choice for_choice hide_list
        play_room "$for_choice"
        ;;
    vo|view-others)
        open_others_dir
        ood_choice=""
        echo "Which room do you want to play?"
        other_room_choice ood_choice
        play_room "$ood_choice"
        ;;
    lo|list-others)
        list_others
        ;;
    fm|fetch-more)
        [[ -z $param ]] && favorite_room_choice param
        fetch_more_rooms "$param"
        ;;
    vm|view-more)
        assert_more_who
        open_more_dir
        ;;
    lm|list-more)
        assert_more_who
        list_more
        ;;
    sc|save-capture)
        [[ -z $param ]] && favorite_room_choice param
        save_capture "$param"
        ;;
    ss|save-stream)
        [[ -z $param ]] && favorite_room_choice param
        save_room "$param"
        ;;
    ps|play-stream)
        [[ -z $param ]] && favorite_room_choice param
        play_room "$param"
        ;;
    ks|keyword-search)
        keyword_search "$param"
        ;;
    ra|random)
        quick_rand "$param"
        ;;
    tn|thumbnail)
        [[ -z $param ]] && favorite_room_choice param
        quick_thumb "$param"
        ;;
    __extract_playlist) # debug proposes
        [[ -z $param ]] && favorite_room_choice param
        valid_username "$param" || send_exit_error $INVALID_USERNAME
        __ep=""
        extract_playlist "$param" __ep
        echo "$__ep"
        ;;
    __clear_favorites)
        clear_favorites_dir
        ;;
    __clear_captures)
        clear_captures_dir
        ;;
    __clear_streams)
        clear_streams_dir
        ;;
    __clear_others)
        clear_others_dir
        ;;
    __clear_all)
        clear_favorites_dir &&
            clear_captures_dir &&
            clear_streams_dir &&
            clear_others_dir
        ;;
    __set_viewer)
        set_viewer "$param"
        ;;
    __check_deps)
        check_dependencies
        ;;
    *)
        send_exit_error $INVALID_COMMAND
        ;;
esac
