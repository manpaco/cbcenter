#!/usr/bin/env bash

# ---------- NAMES -----------
mybasename="$(basename "$0")"
PROJECT="cbcenter"

#
# When using directory variables remember to add a trailing slash.
# For that reason, PDIR stands for (P)artial (DIR)ectory.
#
# ---------- FILES AND DIRECTORIES -----------
if ! [[ -d "${HOME:?HOME var is not assigned !}" ]]; then
    echo "HOME var is not valid !" 1>&2
    exit 1
fi
MYPATH="${HOME}/.local/$PROJECT"
MYCONFIG_PDIR="${HOME}/.config/$PROJECT"
MYCONFIG_FILE="${MYCONFIG_PDIR}/config"
DOWNLOADS_PDIR="${MYPATH}/downloads"
FAVORITES_PDIR="${MYPATH}/favorites"
FAVORITES_FILE="${FAVORITES_PDIR}.cb"
STREAMS_PDIR="${DOWNLOADS_PDIR}/streams"
CAPTURES_PDIR="${DOWNLOADS_PDIR}/captures"
# ----------- TEMP FILES AND DIRECTORIES -------------
TMP_PDIR="/tmp/$PROJECT"
SEARCH_FILE="${TMP_PDIR}/search.cb"
OTHERS_PDIR="${TMP_PDIR}/others"
OTHERS_FILE="${OTHERS_PDIR}.cb"
BIOCONTEXT_FILE="${TMP_PDIR}/biocontext.cb"
MORE_PDIR="${TMP_PDIR}/more"
MORE_FILE="${MORE_PDIR}.cb"
MOREWHO_FILE="${MORE_FILE}.who"
RANDOM_FILE="${TMP_PDIR}/random.cb"

# ----------- FORMATS ---------------
VIDEO_FORMAT="mp4"
IMG_FORMAT="jpg"
CODEC="h264"

# ----------- VIEWER ------------
VIEWER="imv -fd" # <<== I'm here!
OPEN_ENTIRE_DIR=1

# ----------- FETCH ------------
FETCH_TYPE="steps" # 'steps' or 'crazy'
FETCH_STEPS=10

#
# When using url variables remember to add a trailing slash (only when necessary).
# For that reason, PURL stands for (P)artial (URL).
#
# ------------ URLS -------------
PREVIEW_PURL="https://thumb.live.mmcdn.com/riw"
SEARCH_PURL="https://chaturbate.com/ax/search/?keywords=" # not necessary trailing slash
ROOMLIST_PURL="https://chaturbate.com/api/ts/roomlist/room-list"
BIOCONTEXT_PURL="https://chaturbate.com/api/biocontext"
MORELIST_PURL="https://chaturbate.com/api/more_like"

# ------------ REGULAR EXPRESSIONS -------------
FEMALE_ROOM="f"
MALE_ROOM="m"
COUPLE_ROOM="c"
TRANS_ROOM="t"
ID_REGEX="^[0-9]+$"
CB_ROOT_PURL="https://www.chaturbate.com"
CAM_ROOT_REGEX="https:\/\/edge[0-9]+-[a-z]+\.live\.mmcdn\.com"
LIVE_PREFIX="live-"
LIVE_REGEX="${LIVE_PREFIX}(hls|edge)"
USER_PREFIX="amlst:"
USER_REGEX="[A-Za-z0-9_]{3,30}"
USER_SUFFIX="-sd-"
CODE64="[0-9a-z]{64}"
CODE64_SUFFIX="_trns_"
PLAYLIST="playlist.m3u8"
LIVE_USER_REGEX="${LIVE_REGEX}\/${USER_PREFIX}${USER_REGEX}"
EXTRA_STUFF_REGEX="${USER_SUFFIX}${CODE64}${CODE64_SUFFIX}${CODEC}"
LOCATION_REGEX="${LIVE_USER_REGEX}${EXTRA_STUFF_REGEX}"
MINIMAL_CAM_REGEX="${CAM_ROOT_REGEX}\/${LIVE_USER_REGEX}"
COMPLETE_CAM_REGEX="${MINIMAL_CAM_REGEX}${EXTRA_STUFF_REGEX}\/${PLAYLIST}"
CHUNK_REGEX="chunklist_w[0-9]+_b[0-9]+_t[0-9a-zA-Z=]+\.m3u8"
PROG_REGEX="BANDWIDTH=[0-9]+,NAME=\"FPS:[0-9]+\.[0-9]+\",CODECS=\"[a-z0-9.,]*\",RESOLUTION=[0-9]+x[0-9]+"
ROOM_REGEX="^${USER_REGEX}$"
GENDER_REGEX="${FEMALE_ROOM}|${MALE_ROOM}|${COUPLE_ROOM}|${TRANS_ROOM}"
ROOM_RANGE_REGEX="^(($GENDER_REGEX):[0-9]{0,2}:[0-9]{1,2})$"

# ----------- TOOLS ------------
JQ_ONLINE="online"
JQ_OFFLINE="offline"
JQ_HASGTAGS="hashtags"
JQ_RLIST_MAIN="rooms"
JQ_MLIST_MAIN="${JQ_RLIST_MAIN}"
JQ_RLIST_USER="username"
JQ_MLIST_USER="room"
JQ_BIO_RSTATUS="room_status"
XRW_HEADER="X-Requested-With: XMLHttpRequest"
HTTP_NOT_FOUND_TEXT="404 Not Found"
HTTP_TOO_MANY_REQUESTS_TEXT="429 Too Many Requests"
CONNECT_TIMEOUT=10
CHECK_CONNECTION=0

# ----------- EXIT CODES -----------
OK_CODE=0
INVALID_USERNAME=1
OFFLINE_ROOM=2
UNKNOWN_ERROR=3
PLAYLIST_NOT_FOUND=4
CHUNK_NOT_FOUND=5
STORED_ROOM=6
UNSTORED_ROOM=7
EMPTY_DATA=8
INVALID_ROOM_RANGE=9
INVALID_PROG_ID=10
INVALID_KEYWORD=11
INVALID_COMMAND=12
HTTP_NOT_FOUND_ERROR=13
HTTP_TOO_MANY_REQUESTS_ERROR=14
BAD_CHOICE=15
ROOM_LIST_ERROR=16
EMPTY_ROOM_LIST=17
BIOCONTEXT_ERROR=18
JQ_ERROR=19
NOT_PUBLIC_ROOM=20
ROOM_NOT_FOUND=21
CURL_ERROR=22
BANNED_ROOM=23
CONNECTION_ERROR=24
INVALID_GENDER=25
MOREWHO_ERROR=26
EMPTY_DIR=27

# ------------ COLORS -------------
RED_FG="\033[0;31m"
GREEN_FG="\033[0;32m"
LIGHT_BLUE_FG="\033[1;34m"
YELLOW_FG="\033[1;33m"
CLEAR_FG="\033[0m"

valid_fetch_type () {
    [[ "$1" == "steps" || "$1" == "crazy" ]]
}

valid_config_line () {
    [[ "$1" =~ ^(FETCH_TYPE=\".+\")$ ]] ||
        [[ "$1" =~ ^(FETCH_STEPS=\".+\")$ ]] ||
        [[ "$1" =~ ^(VIEWER=\".+\")$ ]] ||
        [[ "$1" =~ ^(CHECK_CONNECTION=\".+\")$ ]] ||
        [[ "$1" =~ ^(OPEN_ENTIRE_DIR=\".+\")$ ]] ||
        [[ -z "$1" ]]
}

check_and_source_config () {
    declare -i nline=1
    while IFS='' read -r rline; do
        if valid_config_line "$rline"; then
            echo "$rline"
        else
            echo -e "${RED_FG}Invalid config line $nline:${CLEAR_FG} '$rline'" 1>&2
        fi
        nline+=1
    done < "$MYCONFIG_FILE" > "${MYCONFIG_FILE}.checked" # only redirect stdout to checked config
    source "${MYCONFIG_FILE}.checked"
    rm "$MYCONFIG_FILE.checked"
}

configure () {
    ! [[ -e "$MYCONFIG_FILE" ]] && return
    local def_ft="$FETCH_TYPE"
    local def_fs="$FETCH_STEPS"
    local def_cc="$CHECK_CONNECTION"
    local def_oed="$OPEN_ENTIRE_DIR"
    check_and_source_config
    if ! valid_fetch_type "$FETCH_TYPE"; then
        FETCH_TYPE="$def_ft"
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Invalid FETCH_TYPE value in config file! Using default '$def_ft'. ${YELLOW_FG}<--${CLEAR_FG}"
    fi
    if ! valid_id "$FETCH_STEPS"; then
        FETCH_STEPS="$def_fs"
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Invalid FETCH_STEPS value in config file! Using default '$def_fs'. ${YELLOW_FG}<--${CLEAR_FG}"
    else
        FETCH_STEPS="$(remove_leading_zeros "$FETCH_STEPS")"
        if [[ $FETCH_STEPS -eq 0 ]]; then
            FETCH_STEPS="$def_fs"
            echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: FETCH_STEPS value equal to 0 in config file! Using default '$def_fs'. ${YELLOW_FG}<--${CLEAR_FG}"
        fi
    fi
    if ! [[ "$CHECK_CONNECTION" =~ ^[0-1]$ ]]; then
        CHECK_CONNECTION="$def_cc"
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Invalid CHECK_CONNECTION value in config file! Using default '$def_cc'. ${YELLOW_FG}<--${CLEAR_FG}"
    fi
    if ! [[ "$OPEN_ENTIRE_DIR" =~ ^[0-1]$ ]]; then
        OPEN_ENTIRE_DIR="$def_oed"
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Invalid OPEN_ENTIRE_DIR value in config file! Using default '$def_oed'. ${YELLOW_FG}<--${CLEAR_FG}"
    fi
    if ! valid_command_string "$VIEWER"; then
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Posible invalid VIEWER value in config file! Check the config. ${YELLOW_FG}<--${CLEAR_FG}"
    fi
}

# Check if a executable if found on PATH
# '$1' executable name
which_check () {
    echo -n "$1: "
    if which "$1" &>/dev/null; then
        echo "OK"
        return $OK_CODE
    else
        echo -e "${RED_FG}NOT FOUND${CLEAR_FG}"
        return $UNKNOWN_ERROR
    fi
}

# Check dependencies and show info on stdout
check_dependencies () {
    echo "Checking dependencies ..."
    which_check curl
    which_check wget
    which_check sed
    which_check jq
    which_check ffmpeg
    which_check ffplay
    echo "Use one of the following image viewers:"
    # If found exact match on the first "word"
    # (continuous characters without spaces) of viewer variable, then show 'using'
    local cd_viewer
    cd_viewer="$(trim_string "$VIEWER")"
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv-dir)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-dir
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv-x11)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-x11
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv-wayland)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-wayland
    echo "... or use what you want. See the help to know how to configure it."
}

# Show favorites limit suggestion
show_add_suggestion () {
    echo -e "${LIGHT_BLUE_FG}SUGGESTION:${CLEAR_FG} Do not add more than 10 favorites to avoid reaching the rate limit too soon."
}

# Show distribution warning
show_dist_warning () {
    echo -e "${RED_FG}CB_WARNING: Do not distribute content (from anywhere) without consent. Personal use only.${CLEAR_FG}"
}

# Show help block
# always call before 'configure' to show correct default values
show_help () {
    echo -e "Manage your favorite rooms from $CB_ROOT_PURL.\n\nUsage:\n\n\
  $mybasename COMMAND OPTION\n\nCommands and options:\n\n\
  a, add             username [username2 [username3 [...]]]\n\
                                 - Add new room(s) to favorites.\n\
  r, remove          [username]  - Remove one room from favorites.\n\
  R, multi-remove                - Remove multiple rooms from favorites.\n\
  ff, fetch-favorites      [-f]  - Fetch previews of favorite rooms. If '-f' is\n\
                                   provided do not check global status(*).
  vf, view-favorites             - Open fetched previews (favorites).\n\
  lf, list-favorites  [-l] [-s]  - List of favorite rooms. If '-s' is provided\n\
                                   show global status(*). If '-l' is provided\n\
                                   show position (line) on favorites file.\n\
  rs, room-status    [-e] [username]\n\
                                 - Show internal status(*). If '-e' is provided\n\
                                   return error on fetch fail (not found or banned).\n\
  rp, room-programs  [username]  - Show available programs of given room.\n\
  ri, room-info      [username]  - Show basic info.\n\
  rb, room-bio       [username]  - Show biocontext.\n\
  fo, fetch-others   [gender]:[offset]:limit [filters]\n\
                                 - Fetch previews of other rooms. See\n\
                                   'Fetch options' section.\n\
  vo, view-others                - Open fetched previews (others).\n\
  lo, list-others                - List of fetched rooms (others).\n\
  fm, fetch-more     [username]  - Fetch previews of rooms like 'username'.\n\
  vm, view-more                  - Open fetched previews (more).\n\
  lm, list-more                  - List of fetched rooms (more).\n\
  sc, save-capture   [username]  - Save a screenshot (high resolution).\n\
  ss, save-stream    [username]  - Save stream of given room.\n\
  ps, play-stream    [username]  - Play stream of given room.\n\
  ks, keyword-search    keyword  - Search a keyword on the website.\n\
  ra, random           [gender]  - Show preview of random room. If 'gender' is\n\
                                   provided, only fetch 'gender' rooms.\n\
  tn, thumbnail      [username]  - Show preview of given room.\n\
  __clear_favorites              - Clear the 'favorites' directory.\n\
  __clear_captures               - Clear the 'captures' directory.\n\
  __clear_streams                - Clear the 'streams' directory.\n\
  __clear_others                 - Clear the 'others' directory.\n\
  __clear_more                   - Clear the 'more' directory.\n\
  __clear_all\n\
  __check_deps                   - Check program dependencies.\n\
  __is_online          username  - Return 0 if online, else 1. Does not check\n\
                                   if the room is active(**).\n\
  __favorites_file               - Show favorites file (path and name).\n\
  h, help                        - This text.\n\n\
(*) There are two types of room status:\n\
    Global: non-detailed room status (less network usage).\n\
            Possible values: online or offline.\n\
    Internal: detailed room status.\n\
              Possible values: public, private, hidden, away, or offline. If\n\
              '-e' option is not provided, also: not found or banned.\n\
    Therefore, \"online\" means that the room can be public, private, hidden,\n\
    or away. On the other hand, \"offline\" could mean the room can be offline,\n\
    not found (does not exist), or banned.\n\
(**) An active room is one that EXISTS and is NOT BANNED.\n\n\
TIP: If [username] is not provided, you will be asked to choose an option\n\
     from your favorites.\n\nConfiguration:\n\n\
  Create a file called 'config' in directory '${MYCONFIG_PDIR}/' and use:\n\n\
  VIEWER=\"<command>\"\n\
    Replace <command> with whatever you want. e.g. VIEWER=\"gpicview\"\n\
    Command used to open images (previews and captures).
    DEFAULT: '$VIEWER'\n\
  FETCH_TYPE=\"<type>\"\n\
    Replace <type> with 'steps' or 'crazy'.\n\
    steps: Fetch x rooms in each iteration until you obtain all of them.\n\
    crazy: Fetch all the rooms at once.\n\
    DEFAULT: '$FETCH_TYPE'\n\
  FETCH_STEPS=\"<int>\"\n\
    Replace <int> with an integer greater than 0.\n\
    Number of rooms fetched in each iteration when user set FETCH_TYPE to 'steps'.
    DEFAULT: '$FETCH_STEPS'\n\
  CHECK_CONNECTION=\"<bool>\"\n\
    Replace <bool> with a boolean integer, i.e. 1 or 0.\n\
    Check connection to main page. If set to 0 ignore check.
    DEFAULT: '$CHECK_CONNECTION'\n\
  OPEN_ENTIRE_DIR=\"<bool>\"\n\
    Repalce <bool> with a boolean integer.\n\
    Open entire directories with VIEWER. If set to 0 open the first file.
    DEFAULT: '$OPEN_ENTIRE_DIR'\n\n\
  Comments and unnecessary spaces are not allowed. e.g. the following lines\n\
  are not valid: '# Setting to 0 because...' or ' VIEWER=\"imv -fd\" '\n\
                  ^ comment                      ^                ^\n\
                                                 ^ unnecessary spaces\nFetch options:\n\n\
  gender: Gender of room users.\n\
          'f' (female) or 'm' (male) or 'c' (couple) or 't' (trans)\n\
          If none is provided, fetch mixed rooms.\n\
  offset: Beginning room.\n\
          Two digits (max) integer from 0 (or 00) to 99.\n\
          If none is provided, the value 0 is taken.\n\
  limit:  Number of rooms.\n\
          Two digits (max) integer from 1 (or 01) to 99.\n\n\
  You can also specify filters:\n\n\
  -a from:to                 --> age range\n\
                                 example: -a 20:25\n\
  -r region[,region2[...]]   --> region(s)\n\
                                 example: -r NA,SA,O\n\
  -h hashtag[,hashtag2[...]] --> hashtag(s)\n\
                                 example: -h hotkeys,bigbus,threadpool\n\n\
  Possible regions: AS (Asia), ER (Europe/Russia), NA (North America),\n\
                    SA (South America), O (Other).\n\nDirectories and files:\n\n\
  PROJECT DIR:   $MYPATH/\n\
  CONFIG DIR:    $MYCONFIG_PDIR/\n\
  CONFIG:        $MYCONFIG_FILE\n\
  DOWNLOADS DIR: $DOWNLOADS_PDIR/\n\
  FAVORITES DIR: $FAVORITES_PDIR/\n\
  FAVORITES:     $FAVORITES_FILE\n\
  TEMPORAL DIR:  $TMP_PDIR/\n\
  MORE DIR:      $MORE_PDIR/\n\
  OTHERS DIR:    $OTHERS_PDIR/\n\
  BIOCONTEXT:    $BIOCONTEXT_FILE\n\
  MORE:          $MORE_FILE\n\
  MORE (who):    $MOREWHO_FILE\n\
  OTHERS:        $OTHERS_FILE\n\
  RANDOM:        $RANDOM_FILE\n\
  SEARCH:        $SEARCH_FILE\n\nFAQs:\n\n\
  - What is a stream 'program'?\n\
      A 'program' represent the video 'channel' or 'quality'. This channels\n\
      are identified by ID, from '0' (lowest quality) to 'n' (highest quality).\n\
      To get programs use 'room-programs' command. You can go to\n\
      FFMPEG Documentation for more info.\n\
  - What do the strange errors mean when I want to play/save/capture/fetch?\n\
      You are probably being blocked by rate limiting.\n\
      A rate limiting solution measures the amount of time between each\n\
      request from each IP address, and also measures the number of\n\
      requests within a specified timeframe. If there are too many\n\
      requests from a single IP within the given timeframe, the rate\n\
      limiting solution will not fulfill the IP address's requests for a\n\
      certain amount of time.\n\
  - How can I change the default image viewer for previews?\n\
      Use VIEWER configuration variable. Remember to set OPEN_ENTIRE_DIR to 0\n\
      if your viewer do not support open entire directories. See 'Configuration'\n\
      section for more info.\n\
  - Why are the rooms fetched in x at a time?\n\
      To avoid reaching the rate limit too soon.\n\
      Also you can change that value (or even disable the option) in 'config'\n\
      file, see 'Configuration' section.\n\
  - How can I change video quality when playing stream?\n\
      Pres 'c' key to cycle stream 'programs'.\n\
      See ffplay documentation for more info.\n\nExamples:\n\n\
  - Add new rooms to favorites:\n\
      $mybasename add bigkeys69 hot_port22 back_xz_door560\n\
  - Fetch the first 10 female rooms:\n\
      $mybasename fetch-others f::10\n\
  - Fetch 30 (couples) rooms starting from 13th:\n\
      $mybasename fetch-others c:13:30\n\
  - Fetch a (random) trans room:\n\
      $mybasename random t\n\
  - Fetch more rooms with a similar appearance and content:\n\
      $mybasename fetch-more userhere\n"
}

# Send error message and exit program
# '$1' error code
send_exit_error () {
    echo -n "$mybasename: error: " 1>&2
    case "$1" in
        "$INVALID_USERNAME")
            echo "invalid username !" 1>&2
            exit $INVALID_USERNAME
            ;;
        "$OFFLINE_ROOM")
            echo "the room is offline !" 1>&2
            exit $OFFLINE_ROOM
            ;;
        "$PLAYLIST_NOT_FOUND")
            echo "while processing the page ! (PLAYLIST_NOT_FOUND)" 1>&2
            exit $PLAYLIST_NOT_FOUND
            ;;
        "$CHUNK_NOT_FOUND")
            echo "while processing room data ! (CHUNK_NOT_FOUND)" 1>&2
            exit $CHUNK_NOT_FOUND
            ;;
        "$STORED_ROOM")
            echo "the room already exists in the favorites list !" 1>&2
            exit $STORED_ROOM
            ;;
        "$UNSTORED_ROOM")
            echo "the room does not exists in the favorites list !" 1>&2
            exit $UNSTORED_ROOM
            ;;
        "$EMPTY_DATA")
            echo "while getting room data ! (EMPTY_DATA)" 1>&2
            exit $EMPTY_DATA
            ;;
        "$INVALID_PROG_ID")
            echo "invalid program ID !" 1>&2
            exit $INVALID_PROG_ID
            ;;
        "$INVALID_KEYWORD")
            echo "invalid keyword to search !" 1>&2
            exit $INVALID_KEYWORD
            ;;
        "$INVALID_COMMAND")
            echo "invalid command. Use '$mybasename help' for more info." 1>&2
            exit $INVALID_COMMAND
            ;;
        "$HTTP_NOT_FOUND_ERROR")
            echo "server response $HTTP_NOT_FOUND_TEXT" 1>&2
            exit $HTTP_NOT_FOUND_ERROR
            ;;
        "$HTTP_TOO_MANY_REQUESTS_ERROR")
            echo "server response $HTTP_TOO_MANY_REQUESTS_TEXT" 1>&2
            exit $HTTP_TOO_MANY_REQUESTS_ERROR
            ;;
        "$INVALID_ROOM_RANGE")
            echo "invalid room range !" 1>&2
            exit $INVALID_ROOM_RANGE
            ;;
        "$BAD_CHOICE")
            echo "'${2:--}' bad choice! (${3:--})" 1>&2
            exit $BAD_CHOICE
            ;;
        "$ROOM_LIST_ERROR")
            echo "while gettig room list !" 1>&2
            exit $ROOM_LIST_ERROR
            ;;
        "$EMPTY_ROOM_LIST")
            echo "empty room list !" 1>&2
            exit $EMPTY_ROOM_LIST
            ;;
        "$BIOCONTEXT_ERROR")
            echo "while getting biocontext" 1>&2
            exit $BIOCONTEXT_ERROR
            ;;
        "$JQ_ERROR")
            echo "while processing json data !" 1>&2
            exit $JQ_ERROR
            ;;
        "$NOT_PUBLIC_ROOM")
            echo "the room is ${2:-not public} !" 1>&2
            exit $NOT_PUBLIC_ROOM
            ;;
        "$ROOM_NOT_FOUND")
            echo "room not found !" 1>&2
            exit $ROOM_NOT_FOUND
            ;;
        "$CURL_ERROR")
            echo "while fetching resource !" 1>&2
            exit $CURL_ERROR
            ;;
        "$BANNED_ROOM")
            echo "the room is banned from the site !" 1>&2
            exit $BANNED_ROOM
            ;;
        "$INVALID_GENDER")
            echo "invalid gender !" 1>&2
            exit $INVALID_GENDER
            ;;
        "$MOREWHO_ERROR")
            echo -e "file '$MOREWHO_FILE' was not found !\n\
Re-run '$mybasename fetch-more username'." 1>&2
            exit $MOREWHO_ERROR
            ;;
        "$EMPTY_DIR")
            echo "the directory is empty !" 1>&2
            exit $EMPTY_DIR
            ;;
        "$CONNECTION_ERROR")
            echo "the connection failed !" 1>&2
            exit $CONNECTION_ERROR
            ;;
        *)
            echo "UNKNOWN_ERROR" 1>&2
            exit $UNKNOWN_ERROR
            ;;
    esac
}

# Wrap username using CB_ROOT_PURL
# '$1' username
wrap_username () {
    echo "${CB_ROOT_PURL}/$1/"
}

# Show search response on stdout
# '$1' keyword
curl_search () {
    curl -sL --compressed -H "$XRW_HEADER" "${SEARCH_PURL}$1"
}

# Alternative and simple global status checker
# With this approach if the rate limit is reached always return offline
alt_is_online () {
    curl_search "$1" | jq -Mc ".${JQ_ONLINE}" | grep -q "\"$1\""
    # You can add stderr redirection to hide jq errors in case of reaching
    # rate limit
    #curl_search "$1" | jq -Mc ".${JQ_ONLINE}" 2>/dev/null | grep -q "\"$1\""
}

# return 0 if online/private/hidden, else offline/connection_error
# '$1' username
# '$2' return value when is not online.
is_online () {
    [[ -n "$2" ]] && declare -n io_out="$2"
    local cs_online
    if ! cs_online="$(curl_search "$1" | jq -Mc ".${JQ_ONLINE}" 2>/dev/null)"; then
        # shellcheck disable=SC2034
        io_out="connection_error"
        return $CONNECTION_ERROR
    fi
    if ! echo "$cs_online" | grep -q "\"$1\""; then
        # shellcheck disable=SC2034
        io_out="offline"
        return $OFFLINE_ROOM
    fi
    return $OK_CODE
}

# Fetch biocontext and extract internal room status
# '$1' room
# '$2' stdout control
fetch_room_status () {
    if ! fetch_bio "$1"; then
        [[ "$2" == "hide" ]] || echo "error"
        return $BIOCONTEXT_ERROR
    fi
    local frs_out
    if ! frs_out="$(jq -Mr ".${JQ_BIO_RSTATUS}" "$BIOCONTEXT_FILE" 2>/dev/null)";
    then
        [[ "$2" == "hide" ]] || echo "not found"
        return $ROOM_NOT_FOUND
    fi
    if [[ "$frs_out" == "null" ]]; then
        [[ "$2" == "hide" ]] || echo "banned"
        return $BANNED_ROOM
    fi
    [[ "$2" == "hide" ]] || echo "$frs_out"
    return $OK_CODE
}

# Store room_status field on '$2' from biocontext file (JSON)
# Also send exit error if the room: doesnt exist or is banned.
# '$1' room
# '$2' store room_status
assert_active_room () {
    if [[ -n "$2" ]]; then
        declare -n rs_out="$2"
        rs_out="$(fetch_room_status "$1")" || send_exit_error $?
        [[ -z "$rs_out" ]] && send_exit_error $UNKNOWN_ERROR
        return $OK_CODE
    fi
    fetch_room_status "$1" hide || send_exit_error $?
}

# return 0 if valid, else 1
# '$1' id
valid_id () {
    [[ "$1" =~ $ID_REGEX ]]
}

# return 0 if valid, else 1
# '$1' room range
valid_room_range () {
    [[ "$1" =~ $ROOM_RANGE_REGEX ]]
}

# Extract programs from playlist data and show on stdout
# '$1' playlist data
show_programs () {
    declare -n sp_data="$1"
    declare -i sp_current=0
    echo "Available programs:"
    while [[ $sp_data =~ $PROG_REGEX ]]; do
        echo -e "\t${YELLOW_FG}PROG_ID=\"$sp_current\"${CLEAR_FG} - ${BASH_REMATCH[0]}"
        sp_data="${sp_data/${BASH_REMATCH[0]}/}"
        sp_current+=1
    done
}

# Get data from playlist and show on stdout
# '$1' room playlist
fetch_data () {
    curl -siL --compressed --connect-timeout "$CONNECT_TIMEOUT" "$1"
}

# Extract playlist from room page
# '$1' username
# '$2' store extracted playlist
extract_playlist () {
    declare -n ep_out="$2"
    local ep_cburl
    ep_cburl="$(wrap_username "$1")"
    local ep_page
    if ! ep_page="$(wget -4 -qS -O - "$ep_cburl" 2>&1)"; then
        [[ "$ep_page" =~ $HTTP_NOT_FOUND_TEXT ]] && send_exit_error $HTTP_NOT_FOUND_ERROR
        [[ "$ep_page" =~ $HTTP_TOO_MANY_REQUESTS_TEXT ]] && send_exit_error $HTTP_TOO_MANY_REQUESTS_ERROR
    fi
    ep_page="$(echo -e "$ep_page")"
    [[ "$ep_page" =~ $COMPLETE_CAM_REGEX ]] || send_exit_error $PLAYLIST_NOT_FOUND
    ep_out="${BASH_REMATCH[0]}"
    [[ -z $ep_out ]] && send_exit_error $UNKNOWN_ERROR
    return $OK_CODE
}

# Extract direct link from playlist. Useful for speedup fetch process of save/capture streams.
# '$1' username
# '$2' store extracted link
extract_direct_link () {
    local dl_link
    extract_playlist "$1" dl_link
    declare -n dl_out="$2"
    local dl_prog
    dl_prog="$3"
    local dl_data
    dl_data="$(fetch_data "$dl_link")"
    [[ -z $dl_data ]] && send_exit_error $EMPTY_DATA
    if [[ -z $dl_prog ]]; then
        show_programs dl_data
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Select a program ID: "
        read -r dl_prog
        valid_id "$dl_prog" || send_exit_error $INVALID_PROG_ID
        dl_prog="$(remove_leading_zeros "$dl_prog")"
    fi
    local dl_chunk
    declare -i dl_current=0
    # Extract chunk from data (chunks are .m3u8 files for specific stream quality)
    # If user choice prog id 0, then first chunk is extracted (low quality stream)
    # For high quality stream, pass high prog id (e.g. 99)
    while [[ $dl_data =~ $CHUNK_REGEX ]] && [[ $dl_current -le $dl_prog ]]; do
        dl_chunk="${BASH_REMATCH[0]}"
        # Remove match from data
        dl_data="${dl_data/${BASH_REMATCH[0]}/}"
        dl_current+=1
    done
    [[ -z $dl_chunk ]] && send_exit_error $CHUNK_NOT_FOUND
    local dl_root_locat
    # In some cases stream is located in another place than main playlist (_link)
    if [[ $dl_data =~ $LOCATION_REGEX ]]; then
        # If new location is found, replace it
        dl_root_locat="${dl_link%%"${LIVE_PREFIX}"*}${BASH_REMATCH[0]}"
    else
        # Else keep location and only remove '/playlist.m3u8' from '_link'
        dl_root_locat="${dl_link%/*}"
    fi
    dl_out="${dl_root_locat}/${dl_chunk}"
    [[ -z $dl_out ]] && send_exit_error $UNKNOWN_ERROR
    return $OK_CODE
}

# return 0 if valid, else 1
# '$1' username
valid_username () {
    [[ "$1" =~ $ROOM_REGEX ]]
}

# Show formated date on stdout
formated_date () {
    date +%Y%m%d%H%M%S
}

# Print the number of lines
# '$1' file
line_count () {
    local lcount
    lcount="$(wc -l "$1" 2>/dev/null)"
    [[ -z "$lcount" ]] && echo 0 && return
    echo "${lcount%% *}"
}

# return 0 if room exists on favorites file, else 1
# '$1' room
stored_room () {
    grep -qx "$1" "$FAVORITES_FILE"
}

# Get favorite room from FAVORITES_FILE using line number
# '$1' line number
get_favorite_line () {
    sed "${1}q;d" "$FAVORITES_FILE"
}

# Remove line from FAVORITES_FILE
# '$1' line number
rem_favorite_line () {
    sed -i "${1:?Empty parameter !}d" "$FAVORITES_FILE" && echo "Done, removed!"
}

choice_message () {
    local wroom
    local echoi
    if [[ "$1" == "multi" ]]; then
        wroom="s"
        echoi="s separated by spaces"
    fi
    echo "  Which room$wroom do you want to ${2:-choose}?"
    echo -en "${YELLOW_FG}==>${CLEAR_FG} Enter your choice$echoi, or (Q)uit: "
}

# Ask the user for a choice, and store the choice on '$1'. If '$2' is other
# than 'hide_list', then show favorites list (with line numbers).
# '$1' store choice
# '$2' hide_list
# '$3' custom action (string after "Which room do you want to...")
favorite_choice () {
    declare -n fc_out="$1"
    [[ $2 == "hide_list" ]] || list_favorites -l
    choice_message single "$3"
    read -r fc_out
    [[ $fc_out == [qQ] || -z "$fc_out" ]] && exit $OK_CODE
    valid_id "$fc_out"  || send_exit_error $BAD_CHOICE "$fc_out" "non-numeric"
    fc_out="$(remove_leading_zeros "$fc_out")"
    [[ "$fc_out" -lt 1 ]] && send_exit_error $BAD_CHOICE "$fc_out" "out of range"
    [[ "$fc_out" -gt "$(line_count "$FAVORITES_FILE")" ]] &&
        send_exit_error $BAD_CHOICE "$fc_out" "out of range"
}

# Uses FAVORITES_FILE
# The same as 'favorite_choice' but store username on '$1'.
# '$1' store username
# '$2' hide_list
# '$3' custom target (string after "Which room do you want to...")
favorite_room_choice () {
    declare -n frc_out="$1"
    local frc_choice
    favorite_choice frc_choice "$2" "$3"
    frc_out="$(get_favorite_line "$frc_choice")"
    [[ -z $frc_out ]] && send_exit_error $UNKNOWN_ERROR
}

# Get the username from OTHERS_FILE using an index
# '$1' index
get_other_by_index () {
    jq -Mre ".${JQ_RLIST_MAIN}[${1:?}].${JQ_RLIST_USER}" "$OTHERS_FILE"
}

# Get the username from MORE_FILE using an index
# '$1' index
get_more_by_index () {
    jq -Mre ".${JQ_MLIST_MAIN}[${1:?}].${JQ_MLIST_USER}" "$MORE_FILE"
}

# Print the number of 'other' rooms
other_rooms_count () {
    local orc_count
    orc_count="$(jq -e ".${JQ_RLIST_MAIN} | length" "$OTHERS_FILE" 2>/dev/null)"
    [[ -z "$orc_count" ]] && echo 0
    echo "$orc_count"
}

# Print the number of 'more' rooms
more_rooms_count () {
    local mrc_count
    mrc_count="$(jq -e ".${JQ_MLIST_MAIN} | length" "$MORE_FILE" 2>/dev/null)"
    [[ -z "$mrc_count" ]] && echo 0
    echo "$mrc_count"
}

# Show list of other rooms with line number
list_others () {
    declare -i num_rooms
    num_rooms="$(other_rooms_count)"
    [[ $num_rooms -eq 0 ]] && send_exit_error $EMPTY_ROOM_LIST
    echo "List of 'other' rooms:"
    for ((i = 0 ; i < num_rooms ; i++)); do
        echo "$i:$(get_other_by_index "$i")"
    done
}

# Show list of more rooms with line number
list_more () {
    declare -i num_rooms
    num_rooms="$(more_rooms_count)"
    [[ $num_rooms -eq 0 ]] && send_exit_error $EMPTY_ROOM_LIST
    echo "List of 'more-like' rooms:"
    for ((i = 0 ; i < num_rooms ; i++)); do
        echo "$i:$(get_more_by_index "$i")"
    done
}

# Remove leading zeros from '$1' and print result
# '$1' to check
remove_leading_zeros () {
    [[ "$1" =~ ^0*$ ]] && echo 0 && return
    echo "${1#"${1%%[!0]*}"}"
}

# Uses OTHERS_FILE
# Ask the user for a choice, and store the username on '$1'
# '$1' store username
# '$2' hide_list
# '$3' custom action (string after "Which room do you want to...")
other_room_choice () {
    declare -n orc_out="$1"
    local orc_choice
    [[ $2 == "hide_list" ]] || list_others
    choice_message single "$3"
    read -r orc_choice
    [[ $orc_choice == [qQ] || -z "$orc_choice" ]] && exit $OK_CODE
    valid_id "$orc_choice" || send_exit_error $BAD_CHOICE "$mrc_choice" "non-numeric"
    orc_choice="$(remove_leading_zeros "$orc_choice")"
    [[ "$((orc_choice+1))" -gt "$(other_rooms_count)" ]] &&
        send_exit_error $BAD_CHOICE "$orc_choice" "out of range"
    orc_out="$(get_other_by_index "$orc_choice")"
    [[ -z $orc_out ]] && send_exit_error $UNKNOWN_ERROR
}

# Uses MORE_FILE
# Ask the user for a choice, and store the username on '$1'
# '$1' store username
# '$2' hide_list
# '$3' custom action (string after "Which room do you want to...")
more_room_choice () {
    declare -n mrc_out="$1"
    local mrc_choice
    [[ $2 == "hide_list" ]] || list_more
    choice_message single "$3"
    read -r mrc_choice
    [[ $mrc_choice == [qQ] || -z "$mrc_choice" ]] && exit $OK_CODE
    valid_id "$mrc_choice" || send_exit_error $BAD_CHOICE "$mrc_choice" "non-numeric"
    mrc_choice="$(remove_leading_zeros "$mrc_choice")"
    [[ "$((mrc_choice+1))" -gt "$(more_rooms_count)" ]] &&
        send_exit_error $BAD_CHOICE "$mrc_choice" "out of range"
    mrc_out="$(get_more_by_index "$mrc_choice")"
    [[ -z $mrc_out ]] && send_exit_error $UNKNOWN_ERROR
}

# Add new rooms to favorites
# '$1' room
add_multi_room () {
    for a in "$@"; do
        if ! valid_username "$a"; then
            echo -e "'$a' ${RED_FG}-->${CLEAR_FG} invalid username."
            continue
        fi
        if stored_room "$a"; then
            echo -e "'$a' ${RED_FG}-->${CLEAR_FG} already in favorites."
            continue
        fi
        local ar_status
        if ! ar_status="$(fetch_room_status "$a")"; then
            echo -e "'$a' ${RED_FG}-->${CLEAR_FG} $ar_status"
            continue
        fi
        echo "$a" >> "$FAVORITES_FILE" && echo -e "'$a' ${LIGHT_BLUE_FG}added${CLEAR_FG}! The room is $ar_status"
    done
}

# Add new room to favorites
# '$1' room
add_room () {
    echo "Adding $1 to favorites ..."
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    stored_room "$1" && send_exit_error $STORED_ROOM
    local ar_status
    assert_active_room "$1" ar_status
    echo "$1" >> "$FAVORITES_FILE" && echo "Favorite added! The room is $ar_status"
}

# Remove room from favorites
# '$1' room
remove_room () {
    if [[ -z "$1" ]]; then
        local rr_choice
        favorite_choice rr_choice show_list remove
        rem_favorite_line "$rr_choice"
        return $OK_CODE
    fi
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    echo "Removing $1 room from favorites ..."
    local match
    if match="$(grep -xn "$1" "$FAVORITES_FILE")"; then # Exact match
        rem_favorite_line "${match%%:*}"
    else # Search partial matches
        # Use '-n' option on grep to use line numbers as choices if partial matches found
        match="$(grep -n "$1" "$FAVORITES_FILE")"
        [[ -z $match ]] && send_exit_error $UNSTORED_ROOM
        echo "No exact match found!"
        echo "$match"
        local rr_choice
        favorite_choice rr_choice hide_list remove
        # Validate choice
        if echo "$match" | grep -q -E "^($rr_choice:)" -; then
            rem_favorite_line "$rr_choice"
        else
            send_exit_error $BAD_CHOICE "$rr_choice" "no match"
        fi
    fi
}

empty_dir () {
    [[ "$(file_count "$1")" -eq 0 ]]
}

# Clear favorites directory
clear_favorites_dir () {
    if rm -f "${FAVORITES_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory FAVORITES deleted!"
    else
        echo -n "  "; echo -e "An ${RED_FG}error${CLEAR_FG} occurred while clearing FAVORITES!"
    fi
}

# Clear captures directory
clear_captures_dir () {
    if rm -f "${CAPTURES_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory CAPTURES deleted!"
    else
        echo -n "  "; echo -e "An ${RED_FG}error${CLEAR_FG} occurred while clearing CAPTURES!"
    fi
}

# Clear streams directory
clear_streams_dir () {
    if rm -f "${STREAMS_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory STREAMS deleted!"
    else
        echo -n "  "; echo -e "An ${RED_FG}error${CLEAR_FG} occurred while clearing STREAMS!"
    fi
}

# Clear rooms directory
clear_others_dir () {
    if rm -f "${OTHERS_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory OTHERS deleted!"
    else
        echo -n "  "; echo -e "An ${RED_FG}error${CLEAR_FG} occurred while clearing OTHERS!"
    fi
}

# Get preview and save it in given file
# '$1' username
# '$2' file
save_preview_in () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" -o "$2"
}

# Get preview and save it in given directory with predefined prefix (custom prefix is optional)
# '$1' username
# '$2' directory
# '$3' custom prefix (optional)
save_preview () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" -o "${2}/$3$(formated_date)-$1.$IMG_FORMAT"
}

# Get preview and show it using image viewer (not save file)
show_preview () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" | $VIEWER -
}

# Print number of files on a directory
# '$1' directory
file_count () {
    find "$1" -maxdepth 1 -type f | wc -l
}

# fetch_favorite_rooms helper
# save preview of '$1' on FAVORITES_PDIR: if success print 'fetched',
# else 'error'. If it is offline print 'offline'.
# '$1' VALID username
# '$2' line prefix
# '$3' force_fetch
ffr_helper () {
    [[ "$3" == "true" || "$3" == "false" ]] || return $UNKNOWN_ERROR
    local ffr_aux
    if $3 || is_online "$1" ffr_aux; then
        local prefix
        [[ $2 -lt 10 ]] && prefix="0$2" || prefix="$2"
        save_preview "$1" "$FAVORITES_PDIR" "$prefix" && echo -e "$2:$1 ${GREEN_FG}fetched${CLEAR_FG}" && return $OK_CODE
        echo -e "$2:$1 ${RED_FG}error${CLEAR_FG}"
        return $UNKNOWN_ERROR
    fi
    if [[ "$ffr_aux" == "offline" ]]; then
        echo "$2:$1 $ffr_aux"
    else
        echo -e "$2:$1 ${YELLOW_FG}${ffr_aux}${CLEAR_FG}"
    fi
}

show_force_info () {
    echo -e "\
${GREEN_FG}INFO:${CLEAR_FG} When using the '-f' option you will probably get previews of rooms that are offline.\n\
  This is because the servers store the last preview for a few hours after going offline."
}

# Get previews of favorites (online only)
fetch_favorite_rooms () {
    echo "Fetching favorite rooms ..."
    show_fetch_message
    clear_favorites_dir
    local rvar

    local force_fetch=false
    if [[ "$1" == "-f" ]]; then
        force_fetch=true
        show_force_info
    fi

    # Crazy implementation
    if [[ "$FETCH_TYPE" == "crazy" ]]; then
        declare -i line=1
        local room
        while IFS="" read -r room || [ -n "$room" ]
        do
            ffr_helper "$room" "$line" "$force_fetch" &
            line+=1
        done < "$FAVORITES_FILE"
        wait
        # Ask to show fetched previews
        local rvar
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] &&
            open_favorites_dir
        return $OK_CODE
    fi

    # Steps implementation
    declare -i line=1
    local old_count
    old_count=0
    local current_count
    local room
    # Read file descriptor 3 (-u 3)
    # That allows us to use 'read' inside the while
    # without an unexpected behavior
    # The problem happens when 'read' is used inside 'read'
    while IFS="" read -u 3 -r room || [ -n "$room" ]; do
        ffr_helper "$room" "$line" "$force_fetch" &
        if [[ $((line%FETCH_STEPS)) -eq 0 ]]; then
            wait
            current_count="$(file_count "${FAVORITES_PDIR}/")"
            if [[ $current_count -ne $old_count ]]; then
                old_count="$current_count"
                echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
                read -r rvar
                [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] &&
                    open_favorites_dir
            fi
            echo -en "${YELLOW_FG}==>${CLEAR_FG} Continue fetching? (Y/n): "
            read -r rvar
            [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] ||
                break
        fi
        line+=1
    done 3< "$FAVORITES_FILE" # Send to file descriptor 3
    wait
    current_count="$(file_count "${FAVORITES_PDIR}/")"
    if [[ $current_count -ne $old_count ]]; then
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] &&
            open_favorites_dir
    fi
}

# Ask to the user to play stream
# '$1' room
ask_to_play () {
    local rplay
    echo -en "${YELLOW_FG}==>${CLEAR_FG} Do you want to play '$1' stream? (Y/n): "
    read -r rplay
    [[ $rplay == [yY] || $rplay == [yY][eE][sS] || -z $rplay ]] || return $OK_CODE
    play_room "$1"
}

# Get and show preview of given room
# '$1' username
quick_thumb () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    echo "Fetching thumbnail from $1 room ..."
    show_preview "$1"
    echo "  $1's room was fetched. Enjoy!"
    ask_to_play "$1"
}

# Open favorites directory
open_favorites_dir () {
    empty_dir "${FAVORITES_PDIR}/" && send_exit_error $EMPTY_DIR
    if [[ $OPEN_ENTIRE_DIR -eq 1 ]]; then
        $VIEWER "$FAVORITES_PDIR"
    else
        local ffiles
        # shellcheck disable=SC2206
        # Quote to prevent word splitting/globbing,
        # or split robustly with mapfile or read -a:
        #read -r -a array <<< "$var"
        ffiles=($FAVORITES_PDIR/*)
        $VIEWER "${ffiles[0]}"
    fi
}

# Make sure the room is public, else exit program with an error
# '$1' room
assert_public_room () {
    local apr_status
    assert_active_room "$1" apr_status
    [[ "$apr_status" == "public" ]] && return $OK_CODE
    [[ "$apr_status" == "offline" ]] && send_exit_error $OFFLINE_ROOM
    #[[ "$apr_status" == "null" ]] && send_exit_error $NOT_PUBLIC_ROOM banned
    send_exit_error $NOT_PUBLIC_ROOM "$apr_status"
}

# Play room stream
# '$1' room
play_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    echo "Wait while resources are obtained ..."
    local pr_link
    extract_playlist "$1" pr_link
    ffplay -i "$pr_link"
}

# Save room stream
# '$1' room
save_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    echo "Wait while resources are obtained ..."
    local sr_link
    extract_direct_link "$1" sr_link
    local output
    output="${STREAMS_PDIR}/$(formated_date)-$1.$VIDEO_FORMAT"
    ffmpeg -i "$sr_link" -codec copy "$output"

    # Another way (slower ffmpeg startup)
    #local sr_link
    #extract_playlist "$1" sr_link
    #ffmpeg -i "$sr_link" -map v:p:$room_prog -map a:p:$room_prog -codec copy "$output"
}

# Save room screenshot
# '$1' room
save_capture () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    echo "Wait while resources are obtained ..."
    local sc_link
    extract_direct_link "$1" sc_link 99
    local output
    output="${CAPTURES_PDIR}/$(formated_date)-$1.$IMG_FORMAT"
    ffmpeg -i "$sc_link" -frames:v 1 -update true "$output"
}

# Show room programs
# '$1' room
room_programs () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    echo "Looking for programs ..."
    local rp_link
    extract_playlist "$1" rp_link
    local rp_data
    rp_data="$(fetch_data "$rp_link")"
    [[ -z $rp_data ]] && send_exit_error $EMPTY_DATA
    show_programs rp_data
}

# Search given keyword
# '$1' keyword
keyword_search () {
    valid_username "$1" || send_exit_error $INVALID_KEYWORD
    curl_search "$1" > "$SEARCH_FILE" || send_exit_error $CURL_ERROR
    echo "Online rooms:"
    jq -e ".${JQ_ONLINE}" "$SEARCH_FILE" 2>/dev/null || send_exit_error $UNKNOWN_ERROR
    echo "Recently online rooms:"
    jq -M ".${JQ_OFFLINE}" "$SEARCH_FILE"
    echo "Hashtags:"
    jq -M ".${JQ_HASGTAGS}" "$SEARCH_FILE"
}

# Show room status
# Only show online or offline (not the same as 'internal_status' function)
global_status () {
    local gs_aux
    if is_online "$1" gs_aux; then
        echo -e "${2:+$2:}$1 ${LIGHT_BLUE_FG}online${CLEAR_FG}"
    else
        if [[ "$gs_aux" == "offline" ]]; then
            echo "${2:+$2:}$1 $gs_aux"
        else
            echo -e "${2:+$2:}$1 ${YELLOW_FG}${gs_aux}${CLEAR_FG}"
        fi
    fi
}

# Show favorites on stdout
# '$1' show global status (-s)
# '$2' show line numbers (-l)
list_favorites () {
    echo "List of 'favorite' rooms:"
    declare -i line=1
    local laux
    local room
    while IFS="" read -r room || [ -n "$room" ]
    do
        if [[ $1 == "-l" || $2 == "-l" ]]; then
            laux="$line"
        else
            laux=""
        fi
        if [[ $1 == "-s" || $2 == "-s" ]]; then
            global_status "$room" "$laux" &
        else
            echo "${laux:+$laux:}$room"
        fi
        line+=1
    done < "$FAVORITES_FILE"
    wait
}

# Open others directory
open_others_dir () {
    empty_dir "${OTHERS_PDIR}/" && send_exit_error $EMPTY_DIR
    if [[ $OPEN_ENTIRE_DIR -eq 1 ]]; then
        $VIEWER "$OTHERS_PDIR"
    else
        local ofiles
        # shellcheck disable=SC2206
        # Quote to prevent word splitting/globbing,
        # or split robustly with mapfile or read -a:
        #read -r -a array <<< "$var"
        ofiles=($OTHERS_PDIR/*)
        $VIEWER "${ofiles[0]}"
    fi
}

# Save rooms list from given range on '$4' file.
# '$1' gender
# '$2' offset
# '$3' limit
# '$4' output
fetch_roomlist_file () {
    curl -sL --compressed -H "$XRW_HEADER" "$ROOMLIST_PURL/?genders=$1&offset=$2&limit=$3&enable_recommendations=false" -o "$4"
}

show_fetch_message () {
    echo -n "  "; echo "Using '${FETCH_TYPE}' fetch type."
    echo -e "${YELLOW_FG}TIP:${CLEAR_FG} Go back in the image viewer to see the most recent ones."
}

# fetch_rooms_using helper
# save preview of '$1' on '$3': if success print 'fetched', else 'error'
# '$1' username
# '$2' index prefix
# '$3' dest dir
fru_helper () {
    local prefix
    [[ $2 -lt 10 ]] && prefix="0$2" || prefix="$2"
    save_preview "$1" "$3" "$prefix" && echo "$2:$1 fetched" && return $OK_CODE
    echo -e "$2:$1 ${RED_FG}error${CLEAR_FG}"
    return $UNKNOWN_ERROR
}

# This abstract function avoids duplicate code.
# But it is probably easier to understand by dividing this function for each
# particular case (room-list and more-list).
# 'room-list' is obtained with fetch_roomlist_file
# 'more-list' is obtained with fetch_morelist_file
# Takes a 'room-list' or 'more-list' from '${1}' file and fetch all.
# '$1' name of json file. Also it is used to extract PDIR taking into account
#      that: e.g. OTHERS_FILE="${OTHERS_PDIR}.cb"
# '$2' main array
# '$3' json field inside main array (used to fetch preview)
# '$4' function name to clear dir
# '$5' function name to open dir
fetch_rooms_using () {
    local fru_file
    fru_file="$1"
    local fru_main
    fru_main="$2"
    local fru_user
    fru_user="$3"
    local fru_clear
    fru_clear="$4"
    local fru_open
    fru_open="$5"
    declare -i num_rooms
    num_rooms="$(jq -e ".$fru_main | length" "$fru_file" 2>/dev/null)" ||
        send_exit_error $JQ_ERROR
    [[ $num_rooms -eq 0 ]] && send_exit_error $EMPTY_ROOM_LIST
    $fru_clear

    local room
    local rvar

    # Implementation to go crazy (without steps)
    if [[ "$FETCH_TYPE" == "crazy" ]]; then
        for ((i = 0 ; i < num_rooms ; i++)); do
            room="$(jq -Mre ".${fru_main}[$i].$fru_user" "$fru_file")"
            fru_helper "$room" "$i" "${fru_file%.*}" &
        done
        wait
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] &&
            $fru_open
        return $OK_CODE
    fi

    # Default implementation with steps (FETCH_STEPS at a time)
    declare -i index=0
    while true; do
        # Fetch room previews by 'FETCH_STEPS' at time
        while room="$(jq -Mre ".${fru_main}[$index].$fru_user" "$fru_file")"; do
            fru_helper "$room" "$index" "${fru_file%.*}" &
            index+=1
            [[ $((index%FETCH_STEPS)) -ne 0 ]] || break
        done
        wait
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] && $fru_open
        [[ $index -eq $num_rooms ]] && break # There are no remaining rooms
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Continue fetching? $((num_rooms-index)) remaining (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] || break
    done
}

# Get and show rooms from given range
# '$1' range
fetch_other_rooms () {
    valid_room_range "$1" || send_exit_error $INVALID_ROOM_RANGE
    local gender
    # Extract gender
    gender="${1%%:*}"
    local offset
    # Extract offset
    offset="${1#*:}"
    offset="${offset%:*}"
    [[ -z $offset ]] && offset=0
    offset="$(remove_leading_zeros "$offset")"
    local limit
    # Extract limit
    limit="${1##*:}"
    limit="$(remove_leading_zeros "$limit")"
    [[ $limit -eq 0 ]] && send_exit_error $INVALID_ROOM_RANGE

    echo "Fetching $gender rooms from $offset to $((offset+limit-1)) ..."
    fetch_roomlist_file "$gender" "$offset" "$limit" "$OTHERS_FILE" || send_exit_error $ROOM_LIST_ERROR
    show_fetch_message
    echo -e "${GREEN_FG}INFO:${CLEAR_FG} Sometimes promoted rooms appear. For this reason, it is possible\n\
that more than $limit rooms will be obtained."

    fetch_rooms_using "$OTHERS_FILE" "$JQ_RLIST_MAIN" "$JQ_RLIST_USER" clear_others_dir open_others_dir
}

# Save biocontext of given room
# '$1' room
fetch_bio () {
    curl -sL --compressed -H "$XRW_HEADER" "${BIOCONTEXT_PURL}/$1" -o "$BIOCONTEXT_FILE"
}

# Show basic info using biocontext
# '$1' room
room_info () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_active_room "$1" # it calls fetch_bio
    echo -n "Real name: "
    jq -M '.real_name' "$BIOCONTEXT_FILE"
    echo -n "Location: "
    jq -M '.location' "$BIOCONTEXT_FILE"
    echo -n "Sex: "
    jq -M '.sex' "$BIOCONTEXT_FILE"
    echo -n "Age: "
    jq -M '.display_age' "$BIOCONTEXT_FILE"
    echo -n "Languages: "
    jq -M '.languages' "$BIOCONTEXT_FILE"
    echo -n "Room status: "
    jq -M ".${JQ_BIO_RSTATUS}" "$BIOCONTEXT_FILE"
    echo -n "Last stream: "
    jq -M '.time_since_last_broadcast' "$BIOCONTEXT_FILE"
}

# Show biocontext
# '$1' room
room_bio () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_active_room "$1" # it calls fetch_bio
    jq . "$BIOCONTEXT_FILE"
}

# 0 if '$1' is a valid 'gender' on the site, else 1
valid_gender () {
    [[ "$1" =~ ^($GENDER_REGEX)$ ]]
}

# Show random preview using a custom range ('$1':RANDOM:1 or RANDOM:RANDOM:1 if '$1' is empty)
# '$1' gender
quick_rand () {
    local gender
    gender="$1"
    [[ -n "$gender" ]] && ! valid_gender "$gender" && send_exit_error $INVALID_GENDER
    [[ -z "$gender" ]] && case $((RANDOM%4)) in
        0) gender=f
            ;;
        1) gender=m
            ;;
        2) gender=c
            ;;
        3) gender=t
            ;;
    esac
    echo "Fetching random room ..."
    fetch_roomlist_file "$gender" $((RANDOM%100)) 1 "$RANDOM_FILE" || send_exit_error $ROOM_LIST_ERROR
    local room
    room="$(jq -Mre ".${JQ_RLIST_MAIN}[0].${JQ_RLIST_USER}" "$RANDOM_FILE" 2>/dev/null)" ||
        send_exit_error $JQ_ERROR
    show_preview "$room"
    echo "  $room's room was fetched ($gender). Enjoy!"
    ask_to_play "$room"
}

# Remove leading and trailing spaces
# '$1' string var
trim_string() {
    local var
    var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    # Use printf instead of echo, due to possible false parameters in echo
    # e.g. if user enters '-e' option on 'room-status'
    # echo interprets 'var' expansion as parameter: echo "$var" --> echo "-e"
    # See echo manual
    printf '%s' "$var"
}

# Verify that '$1' only contains letters, numbers, spaces, and '/' '.' '_' '-' symbols
# '$1' command string
valid_command_string () {
    [[ "$1" =~ ^[a-zA-Z0-9\ \/\._-]+$ ]]
}

# Show room status: public, private, hidden, away, or offline
internal_status () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    local is_status
    if [[ "$2" == "-e" ]]; then
        assert_active_room "$1" is_status
    else
        is_status="$(fetch_room_status "$1")"
        [[ $? -eq $BIOCONTEXT_ERROR ]] && send_exit_error $BIOCONTEXT_ERROR
    fi
    echo -n "Internal status: "
    echo "$is_status"
}

# Discard invalid usernames from FAVORITES_FILE
check_favorites () {
    local rline
    while IFS='' read -r rline; do
        valid_username "$rline" && echo "$rline"
    done < "$FAVORITES_FILE" > "${FAVORITES_FILE}.checked"
    sort -u "$FAVORITES_FILE.checked" > "$FAVORITES_FILE"
    rm "${FAVORITES_FILE}.checked"
}

# Open previews on MORE_PDIR
open_more_dir () {
    empty_dir "${MORE_PDIR}/" && send_exit_error $EMPTY_DIR
    if [[ $OPEN_ENTIRE_DIR -eq 1 ]]; then
        $VIEWER "$MORE_PDIR"
    else
        local mfiles
        # shellcheck disable=SC2206
        # Quote to prevent word splitting/globbing,
        # or split robustly with mapfile or read -a:
        #read -r -a array <<< "$var"
        mfiles=($MORE_PDIR/*)
        $VIEWER "${mfiles[0]}"
    fi
}

# Remove previews on MORE_PDIR
clear_more_dir () {
    if rm -f "${MORE_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory MORE deleted!"
    else
        echo -n "  "; echo "An ${RED_FG}error${CLEAR_FG} occurred while clearing MORE!"
    fi
}

# Fetch rooms list similar to '$1' and save on $MORE_FILE
# '$1' room
fetch_morelist_file () {
    curl -sL --compressed -H "$XRW_HEADER" "${MORELIST_PURL}/$1" -o "$MORE_FILE"
}

# Fetch and show rooms similar to '$1'
# '$1' username
fetch_more_rooms () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_active_room "$1"
    echo "Fetching more rooms like $1 ..."
    fetch_morelist_file "$1" || send_exit_error $ROOM_LIST_ERROR
    echo "$1" > "$MOREWHO_FILE"
    show_fetch_message
    fetch_rooms_using "$MORE_FILE" "$JQ_MLIST_MAIN" "$JQ_MLIST_USER" clear_more_dir open_more_dir
}

# Send exit error when MOREWHO_FILE does not found
assert_more_who () {
    [[ -e "$MOREWHO_FILE" ]] || send_exit_error $MOREWHO_ERROR
}

# Use favorites
# Ask the user for a choice and play
# '$1' hide_list
play_favorite_choice () {
    local pfc_choice
    favorite_room_choice pfc_choice "${1:-show_list}" play
    play_room "$pfc_choice"
}

# Use other rooms
# Ask the user for a choice and play
# '$1' hide_list
play_other_choice () {
    local poc_choice
    other_room_choice poc_choice "${1:-show_list}" play
    play_room "$poc_choice"
}

# Use more like rooms
# Ask the user for a choice and play
# '$1' hide_list
play_more_choice () {
    local pmc_choice
    more_room_choice pmc_choice "${1:-show_list}" play
    play_room "$pmc_choice"
}

# Show 'More rooms like ...'
more_like_message () {
    assert_more_who
    local whois
    whois="$(cat "$MOREWHO_FILE")"
    [[ -z "$whois" ]] && return $UNKNOWN_ERROR
    echo "More rooms like '$whois'"
}

# Ask user for multiple choices
# Store an array of numbers on '$1'
# e.g. the user enters " 4 51 3 04    32 0001 " ---> return (4 51 3 4 32 1)
# '$1' to store
# '$2' hide_list
# '$3' custom target (string after "Which room do you want to...")
favorite_multi_choice () {
    declare -n fc_out="$1"
    [[ $2 == "hide_list" ]] || list_favorites -l
    choice_message multi "$3"
    read -r -a fc_out
    [[ "${fc_out[0]}" == [qQ] || -z "${fc_out[0]}" ]] && exit $OK_CODE
    local lcount
    lcount="$(line_count "$FAVORITES_FILE")"
    #echo "input:     ${fc_out[*]}"
    for i in "${!fc_out[@]}"; do
        valid_id "${fc_out[$i]}"  || send_exit_error $BAD_CHOICE "${fc_out[$i]}" "non-numeric"
        fc_out[i]="$(remove_leading_zeros "${fc_out[$i]}")"
        [[ "${fc_out[$i]}" -lt 1 ]] && send_exit_error $BAD_CHOICE "${fc_out[$i]}" "out of range"
        [[ "${fc_out[$i]}" -gt "$lcount" ]] && send_exit_error $BAD_CHOICE "${fc_out[$i]}" "out of range"
    done
    #echo "sanitized: ${fc_out[*]}"
}

# Ask user for favorites to remove
multi_remove () {
    echo "Multi remove ..."
    local br_choices
    favorite_multi_choice br_choices show_list remove

    # Sort (reverse -r) and keep unique (-u) numbers (-n).
    # Using here-string ( <<< ), process substitution ( <(command) ), and
    # output redirection ( < ). Finally store in array with readarray
    readarray -t br_choices < <(IFS=$'\n'; sort -run <<<"${br_choices[*]}")
    #echo "sorted:    ${br_choices[*]}"

    echo "You are about to delete:"
    for c in "${br_choices[@]}"; do
        echo -n "  "; get_favorite_line "$c"
    done
    echo -en "${YELLOW_FG}==>${CLEAR_FG} Confirm? (Y/n): "
    read -r rvar
    [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] || exit $OK_CODE
    # Remove by line number.
    for c in "${br_choices[@]}"; do
        rem_favorite_line "$c" >/dev/null
    done
    echo "Done, ${#br_choices[@]} favorite(s) removed!"
}

connection_check () {
    [[ $CHECK_CONNECTION -eq 0 ]] && return
    echo "Checking connection ..."
    ping -c 1 "${CB_ROOT_PURL##*/}" &>/dev/null || send_exit_error $CONNECTION_ERROR
}

command="$1"
[[ -n "$command" ]] && command="$(trim_string "$command")"

if [[ "$command" == "__favorites_file" ]]; then
    echo "$FAVORITES_FILE"
    exit $OK_CODE
fi

show_dist_warning

if [[ "$command" == "h" || "$command" == "help" ]]; then
    show_help
    exit $OK_CODE
fi

# __clear_* switch/case
case "$command" in
    __clear_favorites)
        clear_favorites_dir
        exit
        ;;
    __clear_captures)
        clear_captures_dir
        exit
        ;;
    __clear_streams)
        clear_streams_dir
        exit
        ;;
    __clear_others)
        clear_others_dir
        exit
        ;;
    __clear_more)
        clear_more_dir
        exit
        ;;
    __clear_all)
        clear_favorites_dir &&
            clear_captures_dir &&
            clear_streams_dir &&
            clear_others_dir &&
            clear_more_dir
        exit
        ;;
esac

param="$2"
[[ -n "$param" ]] && param="$(trim_string "$param")"

if [[ "$command" == "__is_online" ]]; then
    valid_username "$param" || send_exit_error $INVALID_USERNAME
    alt_is_online "$param"
    # When exit without error code, the value shall be the exit value of the
    # last command executed.
    exit
fi

if [[ "$command" == "__extract_playlist" ]]; then # debug proposes
    [[ -z $param ]] && favorite_room_choice param
    valid_username "$param" || send_exit_error $INVALID_USERNAME
    __ep=""
    extract_playlist "$param" __ep
    echo "$__ep"
    exit
fi

# Make directories
#[[ -d "$MYPATH" ]] || mkdir -p "$MYPATH"
[[ -d "$DOWNLOADS_PDIR" ]] || mkdir -p "$DOWNLOADS_PDIR"
[[ -d "$STREAMS_PDIR" ]] || mkdir -p "$STREAMS_PDIR"
[[ -d "$CAPTURES_PDIR" ]] || mkdir -p "$CAPTURES_PDIR"
[[ -d "$FAVORITES_PDIR" ]] || mkdir -p "$FAVORITES_PDIR"
[[ -d "$OTHERS_PDIR" ]] || mkdir -p "$OTHERS_PDIR"
[[ -d "$MORE_PDIR" ]] || mkdir -p "$MORE_PDIR"
[[ -e "$FAVORITES_FILE" ]] || touch "$FAVORITES_FILE"

check_favorites
configure

# Main switch
case "$command" in
    a|add)
        connection_check
        show_add_suggestion
        # discard "command" parameter
        shift
        if [[ "$#" -gt 1 ]]; then
            declare -a parr
            # Trim all params
            for r in "$@"; do
                parr+=("$(trim_string "$r")")
            done
            # pass all params
            add_multi_room "${parr[@]}"
        else
            add_room "$param"
        fi
        ;;
    r|remove)
        remove_room "$param"
        ;;
    R|multi-remove)
        multi_remove
        ;;
    ff|fetch-favorites)
        connection_check
        fetch_favorite_rooms "$param"
        play_favorite_choice hide_list
        ;;
    vf|view-favorites)
        open_favorites_dir
        connection_check
        play_favorite_choice
        ;;
    lf|list-favorites)
        # discard "command" parameter
        shift
        # search '-s', '-l' params, or combinations
        for p in "$@"; do
            [[ "$p" == "-s" ]] && sparam="$p"
            [[ "$p" == "-l" ]] && lparam="$p"
            [[ "$p" == "-sl" || "$p" == "-ls" ]] && lparam="-l" && sparam="-s"
        done
        [[ -n "$sparam" ]] && connection_check
        list_favorites "$sparam" "$lparam"
        ;;
    rs|room-status)
        connection_check
        # discard "command" parameter
        shift
        if [[ "$#" -gt 1 ]]; then
            # search '-e' param, and use the last parameter found as room
            for e in "$@"; do
                if [[ "$e" == "-e" ]]; then
                    eparam="$e"
                else
                    param="$e"
                fi
            done
            param="$(trim_string "$param")"
            internal_status "$param" "$eparam"
        else
            if [[ -z $param || "$param" == "-e" ]]; then
                [[ "$param" == "-e" ]] && eparam="-e"
                favorite_room_choice param
            fi
            internal_status "$param" "$eparam"
        fi
        ;;
    rp|room-programs)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        room_programs "$param"
        ;;
    ri|room-info)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        room_info "$param"
        ;;
    rb|room-bio)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        room_bio "$param"
        ;;
    fo|fetch-others)
        connection_check
        # discard "command" parameter
        shift
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                -o)
                    [[ -z "$2" ]] && send_exit_error $UNKNOWN_ERROR
                    oparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -l)
                    [[ -z "$2" ]] && send_exit_error $UNKNOWN_ERROR
                    lparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -g)
                    [[ -z "$2" ]] && send_exit_error $UNKNOWN_ERROR
                    gparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -a)
                    [[ -z "$2" ]] && send_exit_error $UNKNOWN_ERROR
                    aparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -r)
                    [[ -z "$2" ]] && send_exit_error $UNKNOWN_ERROR
                    rparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -h)
                    [[ -z "$2" ]] && send_exit_error $UNKNOWN_ERROR
                    hparam="$(trim_string "$2")"
                    shift 2
                    ;;
                *)
                    send_exit_error $UNKNOWN_ERROR
                    ;;
            esac
        done
        echo "oparam: $oparam"
        echo "lparam: $lparam"
        echo "gparam: $gparam"
        echo "aparam: $aparam"
        echo "rparam: $rparam"
        echo "hparam: $hparam"
        #fetch_other_rooms "$param" "$aparam" "$rparam" "$hparam"
        #play_other_choice hide_list
        ;;
    vo|view-others)
        open_others_dir
        connection_check
        play_other_choice
        ;;
    lo|list-others)
        list_others
        ;;
    fm|fetch-more)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        fetch_more_rooms "$param"
        play_more_choice hide_list
        ;;
    vm|view-more)
        more_like_message
        open_more_dir
        connection_check
        play_more_choice
        ;;
    lm|list-more)
        more_like_message
        list_more
        ;;
    sc|save-capture)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        save_capture "$param"
        ;;
    ss|save-stream)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        save_room "$param"
        ;;
    ps|play-stream)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        play_room "$param"
        ;;
    ks|keyword-search)
        connection_check
        keyword_search "$param"
        ;;
    ra|random)
        connection_check
        quick_rand "$param"
        ;;
    tn|thumbnail)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        quick_thumb "$param"
        ;;
    __check_deps)
        check_dependencies
        ;;
    *)
        send_exit_error $INVALID_COMMAND
        ;;
esac
