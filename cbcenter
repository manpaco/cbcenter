#!/bin/bash

# ---------- NAMES -----------
mybasename="$(basename "$0")"
PROJECT="cbcenter"
# ---------- FILES AND DIRECTORIES -----------
MYPATH="${HOME}/.local/$PROJECT"
DOWNLOADS_DIR="${MYPATH}/downloads"
FAVORITES_FILE="${MYPATH}/favorites"
STREAMS_DIR="${DOWNLOADS_DIR}/streams"
CAPTURES_DIR="${DOWNLOADS_DIR}/captures"

# ----------- VIEWER ------------
VIEWER="imv -fd" # <<== I'm here!

# ----------- FORMATS ---------------
VIDEO_FORMAT="mp4"
IMG_FORMAT="jpg"
CODEC="h264"

# ----------- TEMP FILES AND DIRECTORIES -------------
TEMP_DIR="/tmp/$PROJECT"
FAVORITES_DIR="${TEMP_DIR}/favorites"
PREVIEW_URL="https://thumb.live.mmcdn.com/riw"
SEARCH_URL="https://chaturbate.com/ax/search/?keywords="
LASTSEARCH_FILE="${TEMP_DIR}/lastsearch"
ROOMS_DIR="${TEMP_DIR}/rooms"
ROOMS_URL="https://chaturbate.com/api/ts/roomlist/room-list"
LASTROOMS_FILE="${TEMP_DIR}/lastrooms"
FEMALE_ROOM="f"
MALE_ROOM="m"
COUPLE_ROOM="c"
TRANS_ROOM="t"
FETCH_STEPS=10
BIOCONTEXT_URL="https://chaturbate.com/api/biocontext"
BIOCONTEXT_FILE="${TEMP_DIR}/biocontext"
RANDOM_FILE_T="${TEMP_DIR}/random-"

# ------------ REGULAR EXPRESSIONS -------------
ID_REGEX="^[0-9]+$"
CB_ROOT_URL="https://www.chaturbate.com"
CAM_ROOT_REGEX="https:\/\/edge[0-9]+-[a-z]+\.live\.mmcdn\.com"
LIVE_PREFIX="live-"
LIVE_REGEX="${LIVE_PREFIX}(hls|edge)"
USER_PREFIX="amlst:"
USER_REGEX="[A-Za-z0-9_]{3,30}"
USER_SUFFIX="-sd-"
CODE64="[0-9a-z]{64}"
CODE64_SUFFIX="_trns_"
PLAYLIST="playlist.m3u8"
LIVE_USER_REGEX="${LIVE_REGEX}\/${USER_PREFIX}${USER_REGEX}"
EXTRA_STUFF_REGEX="${USER_SUFFIX}${CODE64}${CODE64_SUFFIX}${CODEC}"
LOCATION_REGEX="${LIVE_USER_REGEX}${EXTRA_STUFF_REGEX}"
MINIMAL_CAM_REGEX="${CAM_ROOT_REGEX}\/${LIVE_USER_REGEX}"
COMPLETE_CAM_REGEX="${MINIMAL_CAM_REGEX}${EXTRA_STUFF_REGEX}\/${PLAYLIST}"
CHUNK_REGEX="chunklist_w[0-9]+_b[0-9]+_t[0-9a-zA-Z=]+\.m3u8"
PROG_REGEX="BANDWIDTH=[0-9]+,NAME=\"FPS:[0-9]+\.[0-9]+\",CODECS=\"[a-z0-9.,]*\",RESOLUTION=[0-9]+x[0-9]+"
ROOM_REGEX="^${USER_REGEX}$"
GENDER_REGEX="${FEMALE_ROOM}|${MALE_ROOM}|${COUPLE_ROOM}|${TRANS_ROOM}"
ROOM_RANGE_REGEX="^(($GENDER_REGEX):[0-9]{0,2}:[0-9]{1,2})$"

# ----------- TOOLS ------------
JQ_ONLINE=".online"
JQ_OFFLINE=".offline"
JQ_HASGTAGS=".hashtags"
XRW_HEADER="X-Requested-With: XMLHttpRequest"
HTTP_NOT_FOUND_TEXT="404 Not Found"
HTTP_TOO_MANY_REQUESTS_TEXT="429 Too Many Requests"
CONNECT_TIMEOUT=10

# ----------- EXIT CODES -----------
OK_CODE=0
INVALID_USERNAME=1
OFFLINE_ROOM=2
UNKNOWN_ERROR=3
PLAYLIST_NOT_FOUND=4
CHUNK_NOT_FOUND=5
ROOM_ALREADY_EXIST=6
ROOM_DOESNT_EXIST=7
EMPTY_DATA=8
INVALID_ROOM_RANGE=9
INVALID_PROG_ID=10
INVALID_KEYWORD=11
INVALID_COMMAND=12
HTTP_NOT_FOUND_ERROR=13
HTTP_TOO_MANY_REQUESTS_ERROR=14
BAD_CHOICE=15
ROOM_LIST_ERROR=16
EMPTY_ROOM_LIST=17
BIOCONTEXT_ERROR=19
JQ_ERROR=19
NOT_PUBLIC_ROOM=20
ROOM_NOT_FOUND=21
CURL_ERROR=22

# ------------ COLORS -------------
RED_FG="\033[0;31m"
GREEN_FG="\033[0;32m"
LIGHT_BLUE_FG="\033[1;34m"
YELLOW_FG="\033[1;33m"
CLEAR_FG="\033[0m"

# Check if a executable if found on PATH
# '$1' executable name
which_check () {
    echo -n "$1: "
    if which "$1" &>/dev/null; then
        echo "OK"
        return $OK_CODE
    else
        echo -e "${RED_FG}NOT FOUND${CLEAR_FG}"
        return $UNKNOWN_ERROR
    fi
}

# Check dependencies and show info on stdout
check_dependencies () {
    which_check curl
    which_check wget
    which_check sed
    which_check jq
    which_check ffmpeg
    which_check ffplay
    echo "Use one of the following image viewers:"
    # If found exact match on the first "word"
    # (continuous characters without spaces) of viewer variable, then show 'using'
    echo -n "  "; [[ "${VIEWER%% *}" =~ ^imv$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv
    echo -n "  "; [[ "${VIEWER%% *}" =~ ^imv-x11$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-x11
    echo -n "  "; [[ "${VIEWER%% *}" =~ ^imv-wayland$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-wayland
    echo "... or use what you want. Execute '$mybasename __set_viewer command'."
}

show_dist_warning () {
    echo -e "${RED_FG}WARNING: Do not distribute the content obtained with this program\n\
without the user's consent.${CLEAR_FG}\n"
}

# Show help block
show_help () {
    echo -e "$PROJECT usage:\nManage your favorite rooms from $CB_ROOT_URL.\n\n\
  $mybasename COMMAND OPTION\n\nCommands and options:\n\n\
  add            username    - Add new room to favorites.\n\
  remove         username    - Remove room from favorites.\n\
  list                       - List of favorite rooms.\n\
  global-status  [username]  - Same as 'list' command, plus global\n\
                               status (online/offline). If 'username' is\n\
                               provided, only show that.\n\
  room-status    username    - Show room status (public/private/hidden/offline).
  room-programs  username    - Show available programs of given room.\n\
  room-info      username    - Get biocontext and show basic info.\n\
  room-bio       username    - Show biocontext.\n\
  fetch-rooms    gender:[offset]:limit\n\
                             - Fetch previews of public rooms.\n\
                               See 'Fetch ranges' section.\n\
  view-rooms                 - Open fetched rooms.\n\
  fetch-random   [gender]    - Fetch preview of random room.\n\
                               If 'gender' is provided, only fetch rooms\n\
                               with this 'gender'\n\
  view-random                - Open fetched random.\n\
  fetch-favorites            - Fetch previews of favorite rooms.\n\
  view-favorites             - Open fetched favorites.\n\
  quick-thumb    username    - Show (not save) preview of given room.\n\
  save-capture   username    - Save a screenshot (high resolution).\n\
  view-captures              - Open saved captures.\n\
  save-stream    username    - Save stream of given room.\n\
  play-stream    username    - Play stream of given room.\n\
  search         keyword     - Search a keyword on the website.\n\
  __clear_favorites          - Remove all the fetched preview files.\n\
  __clear_captures           - Remove all the saved capture files.\n\
  __clear_streams            - Remove all the saved stream files.\n\
  __clear_rooms              - Remove all the fetched room files.\n\
  __clear_all\n\
  __set_viewer   command     - Set the 'command' as viewer.\n\
  __check_deps               - Check program dependencies.\n\nFetch ranges:\n\n\
  gender: Gender of room users.\n\
          'f' (female) or 'm' (male) or 'c' (couple) or 't' (trans)\n\
  offset: Begining room.\n\
          Two digits (max) integer from 0 (or 00) to 99.\n\
          If none is provided, the value 0 is taken.\n\
  limit:  Number of rooms.\n\
          Two digits (max) integer from 1 (or 01) to 99.\n\nDirectories and files:\n\n\
  PROJECT DIR:   $MYPATH/\n\
  DOWNLOADS DIR: $DOWNLOADS_DIR/\n\
  FAVORITES:     $FAVORITES_FILE\n\
  TEMPORAL DIR:  $TEMP_DIR/\n\
  FAVORITES DIR: $FAVORITES_DIR/\n\
  ROOMS DIR:     $ROOMS_DIR/\n\
  LAST SEARCH:   $LASTSEARCH_FILE\n\
  LAST ROOMS:    $LASTROOMS_FILE\n\
  BIOCONTEXT:    $BIOCONTEXT_FILE\n\nExit codes:\n\n\
  exit code $HTTP_TOO_MANY_REQUESTS_ERROR)\n\
    You are probably being blocked by rate limiting.\n\
    A rate limiting solution measures the amount of time between each\n\
    request from each IP address, and also measures the number of\n\
    requests within a specified timeframe. If there are too many\n\
    requests from a single IP within the given timeframe, the rate\n\
    limiting solution will not fulfill the IP address's requests for a\n\
    certain amount of time.\n\
  exit code $HTTP_NOT_FOUND_ERROR)\n\
    The room does not exist.\n\
  exit code $EMPTY_DATA or $CHUNK_NOT_FOUND)\n\
    Connection error or corrupted data.\n\
  exit code $PLAYLIST_NOT_FOUND)
    If the room is online it could be private or hidden, otherwise it\n\
    is offline. You can use 'room-status' command to see room status, i.e.\n\
    public/private/hidden/offline.\n\nFAQs:\n\n\
  - What is a 'program ID'?\n\
      A 'program' represent the stream 'channel' or 'quality'. This channels\n\
      are identified by ID, from '0' (lowest quality) to 'n' (highest quality).\n\
      To get cam programs use 'info' command. You can go to FFMPEG Documentation\n\
      for more info.\n\
  - What do the strange errors mean when I want to play/save/capture?\n\
      See 'Exit codes' section.
  - How can I change the default image viewer for previews?\n\
      Just change the 'VIEWER' variable to whatever you want (within the\n\
      executable), or use '__set_viewer' command. See 'Examples' section.\n\
      NOTE: the image viewer must support opening entire directories.\n\
  - Why are the rooms fetched in $FETCH_STEPS at a time?\n\
      To avoid error code $HTTP_TOO_MANY_REQUESTS_ERROR. See 'Exit codes' section.\n\nExamples:\n\n\
  - Fetch the first 10 female rooms:\n\
      $mybasename fetch-rooms f::10\n\
  - Fetch 30 (couples) rooms starting from 13th:\n\
      $mybasename fetch-rooms c:13:30\n\
  - Fetch a (random) trans room:\n\
      $mybasename fetch-random t\n\
  - Set the image viewer:
      $mybasename __set_viewer gpicview\n\
      $mybasename __set_viewer \"imv-wayland -fd\"\n"
}

# Send error messange and exit program
# '$1' error code
send_exit_error () {
    case "$1" in
        "$INVALID_USERNAME")
            echo "Invalid username !" 1>&2
            exit $INVALID_USERNAME
            ;;
        "$OFFLINE_ROOM")
            echo "The room is offline !" 1>&2
            exit $OFFLINE_ROOM
            ;;
        "$PLAYLIST_NOT_FOUND")
            echo "An error occurred while processing the page ! (PLAYLIST_NOT_FOUND)" 1>&2
            exit $PLAYLIST_NOT_FOUND
            ;;
        "$CHUNK_NOT_FOUND")
            echo "An error occurred while processing room data ! (CHUNK_NOT_FOUND)" 1>&2
            exit $CHUNK_NOT_FOUND
            ;;
        "$ROOM_ALREADY_EXIST")
            echo "The room already exists in the favorites list !" 1>&2
            exit $ROOM_ALREADY_EXIST
            ;;
        "$ROOM_DOESNT_EXIST")
            echo "The room does not exists in the favorites list !" 1>&2
            exit $ROOM_DOESNT_EXIST
            ;;
        "$EMPTY_DATA")
            echo "Error getting room data ! (EMPTY_DATA)" 1>&2
            exit $EMPTY_DATA
            ;;
        "$INVALID_PROG_ID")
            echo "Invalid program ID !" 1>&2
            exit $INVALID_PROG_ID
            ;;
        "$INVALID_KEYWORD")
            echo "Invalid keyword to search !" 1>&2
            exit $INVALID_KEYWORD
            ;;
        "$INVALID_COMMAND")
            echo "Error: invalid command. Use '$mybasename help' for more info." 1>&2
            exit $INVALID_COMMAND
            ;;
        "$HTTP_NOT_FOUND_ERROR")
            echo "Server response: $HTTP_NOT_FOUND_TEXT" 1>&2
            exit $HTTP_NOT_FOUND_ERROR
            ;;
        "$HTTP_TOO_MANY_REQUESTS_ERROR")
            echo "Server response: $HTTP_TOO_MANY_REQUESTS_TEXT" 1>&2
            exit $HTTP_TOO_MANY_REQUESTS_ERROR
            ;;
        "$INVALID_ROOM_RANGE")
            echo -e "Invalid room range !" 1>&2
            exit $INVALID_ROOM_RANGE
            ;;
        "$BAD_CHOICE")
            echo -e "Bad choice !" 1>&2
            exit $BAD_CHOICE
            ;;
        "$ROOM_LIST_ERROR")
            echo -e "Error gettig room list !" 1>&2
            exit $ROOM_LIST_ERROR
            ;;
        "$EMPTY_ROOM_LIST")
            echo -e "Empty room list !" 1>&2
            exit $EMPTY_ROOM_LIST
            ;;
        "$BIOCONTEXT_ERROR")
            echo -e "Error getting biocontext" 1>&2
            exit $BIOCONTEXT_ERROR
            ;;
        "$JQ_ERROR")
            echo -e "An error occurred while processing json data !" 1>&2
            exit $JQ_ERROR
            ;;
        "$NOT_PUBLIC_ROOM")
            echo -e "The room is not public (${2:-private/hidden}) !" 1>&2
            exit $NOT_PUBLIC_ROOM
            ;;
        "$ROOM_NOT_FOUND")
            echo -e "Room not found !" 1>&2
            exit $ROOM_NOT_FOUND
            ;;
        "$CURL_ERROR")
            echo -e "An error occurred while fetching resource !" 1>&2
            exit $CURL_ERROR
            ;;
        *)
            echo "UNKNOWN_ERROR" 1>&2
            exit $UNKNOWN_ERROR
            ;;
    esac
}

# Wrap username using cb url
# '$1' username
wrap_username () {
    echo "${CB_ROOT_URL}/$1/"
}

# Show search response on stdout
# '$1' keyword
curl_search () {
    curl -sL --compressed -H "$XRW_HEADER" "${SEARCH_URL}$1"
}

# return 0 if online/private/hidden, else 1 (offline)
# '$1' username
is_online () {
    curl_search "$1" | jq -Mc $JQ_ONLINE | grep -q "\"$1\""
}

# Print room_status field from biocontext file (JSON)
# '$1' room
room_status () {
    declare -n rs_out="$2"
    get_bio "$1"
    rs_out="$(jq -Mr '.room_status' "$BIOCONTEXT_FILE" 2>/dev/null)" ||
        send_exit_error $ROOM_NOT_FOUND
}

# return 0 if room is public, else 1 (private/hidden/offline)
# not use in parallel jobs (using '&' at the end of function call)
# Alternative implementation (store status on the second param)
# '$1' room
# '$2' status (out)
is_public_alt () {
    declare -n ipa_out="$2"
    room_status "$1" ipa_out
    [[ "$ipa_out" == "public" ]]
}

# return 0 if room is public, else 1 (private/hidden/offline)
# not use in parallel jobs (using '&' at the end of function call)
# '$1' room
is_public () {
    local ip_status
    room_status "$1" ip_status
    [[ "$ip_status" == "public" ]]
}

# return 0 if valid, else 1
# '$1' id
valid_id () {
    [[ "$1" =~ $ID_REGEX ]]
}

# return 0 if valid, else 1
# '$1' room range
valid_room_range () {
    [[ "$1" =~ $ROOM_RANGE_REGEX ]]
}

# Extract programs from playlist data and show on stdout
# '$1' playlist data
get_programs () {
    declare -n gp_data="$1"
    local _progs
    declare -i _current=0
    while [[ $gp_data =~ $PROG_REGEX ]]; do
        _progs="$_progs\t${YELLOW_FG}PROG_ID=\"$_current\"${CLEAR_FG} - ${BASH_REMATCH[0]}\n"
        gp_data="${gp_data/${BASH_REMATCH[0]}/}"
        _current+=1
    done
    echo -e "$_progs"
}

# Get data from playlist and show on stdout
# '$1' room playlist
get_data () {
    curl -siL --compressed --connect-timeout "$CONNECT_TIMEOUT" "$1"
}

# Extract playlist from room page
# '$1' username
# '$2' store extracted playlist
extract_playlist () {
    declare -n ep_out="$2"
    local _cburl
    _cburl="$(wrap_username "$1")"
    local _page
    if ! _page="$(wget -4 -qS -O - "$_cburl" 2>&1)"; then
        [[ "$_page" =~ $HTTP_NOT_FOUND_TEXT ]] && send_exit_error $HTTP_NOT_FOUND_ERROR
        [[ "$_page" =~ $HTTP_TOO_MANY_REQUESTS_TEXT ]] && send_exit_error $HTTP_TOO_MANY_REQUESTS_ERROR
    fi
    _page="$(echo -e "$_page")"
    [[ "$_page" =~ $COMPLETE_CAM_REGEX ]] || send_exit_error $PLAYLIST_NOT_FOUND
    ep_out="${BASH_REMATCH[0]}"
    return $OK_CODE
}

# Extract direct link from playlist. Useful for speedup fetch process of save/capture streams.
# '$1' username
# '$2' store extracted link
direct_link () {
    local _link
    extract_playlist "$1" _link
    declare -n dl_out="$2"
    local _prog="$3"
    local _data
    _data="$(get_data "$_link")"
    [[ -z $_data ]] && send_exit_error $EMPTY_DATA
    if [[ -z $_prog ]]; then
        get_programs _data
        read -rp "Select a program ID: " _prog
        valid_id "$_prog" || send_exit_error $INVALID_PROG_ID
    fi
    local _chunk
    declare -i _current=0
    # Extract chunk from data (chunks are .m3u8 files for specific stream quality)
    # If user choice prog id 0, then first chunk is extracted (low quality stream)
    # For high quality stream, pass high prog id (e.g. 99)
    while [[ $_data =~ $CHUNK_REGEX ]] && [[ $_current -le $_prog ]]; do
        _chunk="${BASH_REMATCH[0]}"
        # Remove match from data
        _data="${_data/${BASH_REMATCH[0]}/}"
        _current+=1
    done
    [[ -z $_chunk ]] && send_exit_error $CHUNK_NOT_FOUND
    local _root_locat
    # In some cases stream is located in another place than main playlist (_link)
    if [[ $_data =~ $LOCATION_REGEX ]]; then
        # If new location is found, replace it
        _root_locat="${_link%%"${LIVE_PREFIX}"*}${BASH_REMATCH[0]}"
    else
        # Else keep location and only remove '/playlist.m3u8' from '_link'
        _root_locat="${_link%/*}"
    fi
    dl_out="${_root_locat}/${_chunk}"
    return $OK_CODE
}

# return 0 if valid, else 1
# '$1' username
valid_username () {
    [[ "$1" =~ $ROOM_REGEX ]]
}

# Show formated date on stdout
formated_date () {
    date +%Y%m%d%H%M%S
}

# return 0 if room exists on favorites file, else 1
# '$1' room
room_exists () {
    grep -qx "$1" "$FAVORITES_FILE"
}

# Add new room to favorites
# '$1' room
add_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    room_exists "$1" && send_exit_error $ROOM_ALREADY_EXIST
    echo "$1" >> "$FAVORITES_FILE" && echo "Favorite added!"
}

# Remove room from favorites
# '$1' room
remove_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    if match="$(grep -xn "$1" "$FAVORITES_FILE")"; then # Exact match
        sed -i "${match%%:*}d" "$FAVORITES_FILE" && echo "Favorite removed!"
        echo "devel"
    else # Search partial matches
        # Use '-n' option on grep to use line numbers as choices if partial matches found
        match="$(grep -n "$1" "$FAVORITES_FILE")"
        [[ -z $match ]] && send_exit_error $ROOM_DOESNT_EXIST
        echo "No exact match found!"
        echo "$match"
        read -rp "Type your choice to remove it (i.e. the beginning number before the ':'), or (q)uit: " line
        [[ $line == q ]] && return $OK_CODE
        valid_id "$line" || send_exit_error $BAD_CHOICE
        # Validate choice
        if echo "$match" | grep -q -E "^($line:)" -; then
            sed -i "${line}d" "$FAVORITES_FILE" && echo "Favorite removed!"
        else
            send_exit_error $BAD_CHOICE
        fi
    fi
}

# Clear favorites directory
clear_favorites_dir () {
    rm -f ${FAVORITES_DIR:?}/*
}

# Clear captures directory
clear_captures_dir () {
    rm -f ${CAPTURES_DIR:?}/*
}

# Clear streams directory
clear_streams_dir () {
    rm -f ${STREAMS_DIR:?}/*
}

# Clear rooms directory
clear_rooms_dir () {
    rm -f ${ROOMS_DIR:?}/*
}

# Get preview and save it in given file
# '$1' username
# '$2' file
save_preview_in () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_URL}/$1.$IMG_FORMAT" -o "$2"
}

# Get preview and save it in given directory with predefined preffix (custom preffix is optional)
# '$1' username
# '$2' directory
# '$3' custom preffix (optional)
save_preview () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_URL}/$1.$IMG_FORMAT" -o "${2}/$3$(formated_date)-$1.$IMG_FORMAT"
}

# Get preview and show it using image viewer (not save file)
show_preview () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_URL}/$1.$IMG_FORMAT" | $VIEWER -
}

ff_helper () {
    valid_username "$1" && is_online "$1" && save_preview "$1" "$FAVORITES_DIR" && echo "$1 fetched" && return $OK_CODE
    echo -e "$1 ${RED_FG}error${CLEAR_FG}"
    return $UNKNOWN_ERROR
}

# Get previews of favorites (online only)
fetch_favorites () {
    clear_favorites_dir
    while IFS="" read -r room || [ -n "$room" ]
    do
        ff_heler "$room" &
    done < "$FAVORITES_FILE"
    wait
    # Ask to show fetched previews
    read -rp "Open fetched previews? (Y/N): " save
    [[ $save == [yY] || $save == [yY][eE][sS] ]] || return $OK_CODE
    open_favorites_dir
}

# Get and show preview of given room
# '$1' username
quick_thumb () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    show_preview "$1"
}

# Open favorites directory
open_favorites_dir () {
    $VIEWER "$FAVORITES_DIR"
}

# Make sure the room is public, else exit program with an error
# Alternative implementation (less network usage)
# '$1' room
assert_public_room_alt () {
    local apra_status
    is_public_alt "$1" apra_status && return $OK_CODE
    [[ "$apra_status" == "offline" ]] && send_exit_error $OFFLINE_ROOM
    send_exit_error $NOT_PUBLIC_ROOM "$apra_status"
}

# Make sure the room is public, else exit program with an error
# '$1' room
assert_public_room () {
    is_public "$1" && return $OK_CODE
    ! is_online "$1" && send_exit_error $OFFLINE_ROOM
    send_exit_error $NOT_PUBLIC_ROOM
}

# Play room stream
# '$1' room
play_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room_alt "$1"
    local room_link
    extract_playlist "$1" room_link
    ffplay -i "$room_link"
}

# Save room stream
# '$1' room
save_room () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    local room_link
    direct_link "$1" room_link
    local output
    output="${STREAMS_DIR}/$(formated_date)-$1.$VIDEO_FORMAT"
    ffmpeg -i "$room_link" -codec copy "$output"

    # Another way (slower ffmpeg startup)
    #extract_playlist "$1" room_link
    #room_prog=99
    #ffmpeg -i "$room_link" -map v:p:$room_prog -map a:p:$room_prog -codec copy "$output"
}

# Save room screenshot
# '$1' room
room_capture () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    local room_link
    direct_link "$1" room_link 99
    local output
    output="${CAPTURES_DIR}/$(formated_date)-$1.$IMG_FORMAT"
    ffmpeg -i "$room_link" -frames:v 1 -update true "$output"
}

# Show room programs
# '$1' room
room_programs () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    assert_public_room "$1"
    local room_link
    extract_playlist "$1" room_link
    local room_data
    room_data="$(get_data "$room_link")"
    [[ -z $room_data ]] && send_exit_error $EMPTY_DATA
    get_programs room_data
}

# Search given keyword
# '$1' keyword
keyword_search () {
    valid_username "$1" || send_exit_error $INVALID_KEYWORD
    curl_search "$1" > "$LASTSEARCH_FILE" || send_exit_error $CURL_ERROR
    echo "Online rooms:"
    jq "$JQ_ONLINE" "$LASTSEARCH_FILE"
    echo "Recently online rooms:"
    jq -M "$JQ_OFFLINE" "$LASTSEARCH_FILE"
    echo "Hashtags:"
    jq -M "$JQ_HASGTAGS" "$LASTSEARCH_FILE"
}

# Show status of given room
# '$1' room
show_online_offline () {
    if is_online "$1"; then
        echo -e "$1 is ${LIGHT_BLUE_FG}online${CLEAR_FG}"
    else
        echo "$1 is offline"
    fi
}

# Show status of favorites
status_all () {
    while IFS="" read -r room || [ -n "$room" ]
    do
        valid_username "$room" && show_online_offline "$room" &
    done < "$FAVORITES_FILE"
    wait
}

# If '$1' is not empty, show room status. Else show status of favorites
# Only show online or offline (not the same as 'room_status' function)
# '$1' room (optional)
global_status () {
    if [[ -z $1 ]]; then
        status_all
    else
        valid_username "$1" || send_exit_error $INVALID_USERNAME
        show_online_offline "$1"
    fi
}

# Show favorites on stdout
favorites_list () {
    while IFS="" read -r room || [ -n "$room" ]
    do
        echo "$room"
    done < "$FAVORITES_FILE"
}

# Open rooms directory
open_rooms_dir () {
    $VIEWER "$ROOMS_DIR"
}

# Save rooms list from given range
# '$1' gender
# '$2' offset
# '$3' limit
save_room_list () {
    curl -sL --compressed -H "$XRW_HEADER" "$ROOMS_URL/?genders=$1&offset=$2&limit=$3&enable_recommendations=false" -o "$LASTROOMS_FILE"
}

frr_helper () {
    save_preview "$1" "$ROOMS_DIR" "$2" && echo "$1 fetched" && return $OK_CODE
    echo -e "$1 ${RED_FG}error${CLEAR_FG}"
    return $UNKNOWN_ERROR
}

# Get and show rooms from given range
# '$1' range
fetch_room_range () {
    valid_room_range "$1" || send_exit_error $INVALID_ROOM_RANGE
    local gender
    # Extract gender
    gender="${1%%:*}"
    local offset
    # Extract offset
    offset="${1#*:}"
    offset="${offset%:*}"
    [[ -z $offset ]] && offset=0
    # If offset contains 2 digits, remove 0 from beginning if exist. (09 -> 9)
    [[ ${#offset} -ne 1 ]] && offset="${offset#0}"
    local limit
    # Extract limit
    limit="${1##*:}"
    [[ ${#limit} -ne 1 ]] && limit="${limit#0}"
    [[ $limit -eq 0 ]] && send_exit_error $INVALID_ROOM_RANGE

    echo "Fetching $gender rooms from $offset to $((offset+limit-1)) ..."

    save_room_list "$gender" "$offset" "$limit" || send_exit_error $ROOM_LIST_ERROR
    declare -i num_rooms
    num_rooms="$(jq -e '.rooms | length' "$LASTROOMS_FILE")" || send_exit_error $JQ_ERROR
    [[ $num_rooms -eq 0 ]] && send_exit_error $EMPTY_ROOM_LIST
    echo -e "${GREEN_FG}TIP:${CLEAR_FG} Go back in the image viewer to see the most recent ones."
    # In some cases promoted rooms are found
    [[ $limit -lt $num_rooms ]] && echo -e "$GREEN_FG$((num_rooms-limit)) promoted room(s) found !$CLEAR_FG"
    clear_rooms_dir

    declare -i index=0
    local preffix
    local room
    while true; do
        # Fetch room previews by 'FETCH_STEPS' at time
        while room="$(jq -Mre ".rooms[$index].username" "$LASTROOMS_FILE")"; do
            index+=1
            [[ $index -lt 10 ]] && preffix="0$index" || preffix="$index"
            frr_helper "$room" "$preffix" &
            [[ $((index%FETCH_STEPS)) -ne 0 ]] || break
        done
        wait
        read -rp "Open previews of fetched rooms? (Y/N): " save
        [[ $save == [yY] || $save == [yY][eE][sS] ]] && open_rooms_dir
        [[ $index -eq $num_rooms ]] && break # There are no remaining rooms
        read -rp "Continue fetching previews? $((num_rooms-index)) remaining (Y/N): " save
        [[ $save == [yY] || $save == [yY][eE][sS] ]] || break
    done
}

# Save biocontext of given room
# '$1' room
get_bio () {
    curl -sL --compressed -H "$XRW_HEADER" "${BIOCONTEXT_URL}/$1" -o "$BIOCONTEXT_FILE" || send_exit_error $BIOCONTEXT_ERROR
}

# Show basic info using biocontext
# '$1' room
room_info () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    get_bio "$1"
    echo -n "Real name: "
    jq -M '.real_name' "$BIOCONTEXT_FILE" 2>/dev/null || send_exit_error $ROOM_NOT_FOUND
    echo -n "Location: "
    jq -M '.location' "$BIOCONTEXT_FILE"
    echo -n "Sex: "
    jq -M '.sex' "$BIOCONTEXT_FILE"
    echo -n "Age: "
    jq -M '.display_age' "$BIOCONTEXT_FILE"
    echo -n "Languages: "
    jq -M '.languages' "$BIOCONTEXT_FILE"
    echo -n "Room status: "
    jq -M '.room_status' "$BIOCONTEXT_FILE"
    echo -n "Last stream: "
    jq -M '.time_since_last_broadcast' "$BIOCONTEXT_FILE"
}

# Show biocontext
# '$1' room
room_bio () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    get_bio "$1"
    jq . "$BIOCONTEXT_FILE" 2>/dev/null || send_exit_error $ROOM_NOT_FOUND
}

# Clear random file
clear_random_file () {
    rm -f ${RANDOM_FILE_T:?}*
}

# Open random file
open_random_file () {
    $VIEWER ${RANDOM_FILE_T:?}*
}

# Fetch random preview using a custom range ('$1':RANDOM:1 or RANDOM:RANDOM:1 if '$1' is empty)
# '$1' gender
fetch_random_room () {
    local gender="$1"
    if [[ -n "$gender" ]] && ! [[ "$gender" =~ ^($GENDER_REGEX)$ ]]; then
        echo "Invalid gender" 2>&1
        exit $UNKNOWN_ERROR
    fi
    [[ -z "$gender" ]] && case $((RANDOM%4)) in
        0) gender=f
            ;;
        1) gender=m
            ;;
        2) gender=c
            ;;
        3) gender=t
            ;;
    esac
    save_room_list "$gender" $((RANDOM%100)) 1 || send_exit_error $ROOM_LIST_ERROR
    room="$(jq -Mre ".rooms[0].username" "$LASTROOMS_FILE")" || send_exit_error $JQ_ERROR
    clear_random_file
    save_preview_in "$room" "$RANDOM_FILE_T${room}.$IMG_FORMAT" || send_exit_error $CURL_ERROR
    open_random_file
    echo "Fetched $room room ($gender). Enjoy!"
}

# Open captures directory
open_captures_dir () {
    $VIEWER "$CAPTURES_DIR"
}

# Remove leading and trailing spaces
# '$1' string var
trim_string() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo "$var"
}

# Set the image viewer command
# '$1' image viewer
set_viewer () {
    # Verify that only contains letters, numbers, spaces, and '/' '.' '_' '-' symbols
    if ! [[ "$1" =~ ^[a-zA-Z0-9\ \/\._-]+$ ]]; then
        echo "Invalid image viewer" 2>&1
        return $UNKNOWN_ERROR
    fi
    echo "Setting image viewer ..."
    # Verify if it is on PATH
    if ! which_check "${1%% *}"; then
        echo "... but not found on PATH"
        read -rp "Set anyway? (Y/N): " choice
        [[ $choice == [yY] || $choice == [yY][eE][sS] ]] || return $UNKNOWN_ERROR
    fi
    # Escape slashes with backslashes: ${1//\//\\\/} (the first two slashes means 'replace all')
    sed -i --follow-symlinks "s/VIEWER=\".*\"/VIEWER=\"${1//\//\\\/}\"/" "$0"
    echo "Now you are using '$1'"
}

# Show room status (public/private/hidden/offline)
intern_status () {
    valid_username "$1" || send_exit_error $INVALID_USERNAME
    local is=""
    room_status "$1" is
    echo "$is"
}

# Make directories
mkdir -p "$MYPATH"
mkdir -p "$DOWNLOADS_DIR"
mkdir -p "$STREAMS_DIR"
mkdir -p "$CAPTURES_DIR"
mkdir -p "$FAVORITES_DIR"
mkdir -p "$ROOMS_DIR"
touch "$FAVORITES_FILE"

show_dist_warning

[[ -n "$2" ]] && param="$(trim_string "$2")"

# Main switch
case "$1" in
    add)
        add_room "$param"
        ;;
    remove)
        remove_room "$param"
        ;;
    list)
        favorites_list
        ;;
    global-status)
        global_status "$param"
        ;;
    room-status)
        intern_status "$param"
        ;;
    room-programs)
        room_programs "$param"
        ;;
    room-info)
        room_info "$param"
        ;;
    room-bio)
        room_bio "$param"
        ;;
    fetch-rooms)
        fetch_room_range "$param"
        ;;
    view-rooms)
        open_rooms_dir
        ;;
    fetch-random)
        fetch_random_room "$param"
        ;;
    view-random)
        open_random_file
        ;;
    fetch-favorites)
        fetch_favorites
        ;;
    view-favorites)
        open_favorites_dir
        ;;
    quick-thumb)
        quick_thumb "$param"
        ;;
    save-capture)
        room_capture "$param"
        ;;
    view-captures)
        open_captures_dir
        ;;
    save-stream)
        save_room "$param"
        ;;
    play-stream)
        play_room "$param"
        ;;
    search)
        keyword_search "$param"
        ;;
    __extract_playlist) # debug proposes
        valid_username "$param" || send_exit_error $INVALID_USERNAME
        __ep=""
        extract_playlist "$param" __ep
        echo "$__ep"
        ;;
    __clear_favorites)
        clear_favorites_dir
        ;;
    __clear_captures)
        clear_captures_dir
        ;;
    __clear_streams)
        clear_streams_dir
        ;;
    __clear_random)
        clear_random_file
        ;;
    __clear_rooms)
        clear_rooms_dir
        ;;
    __clear_all)
        clear_favorites_dir &&
            clear_captures_dir &&
            clear_streams_dir &&
            clear_random_file &&
            clear_rooms_dir
        ;;
    __set_viewer)
        set_viewer "$param"
        ;;
    __check_deps)
        check_dependencies
        ;;
    help)
        show_help
        ;;
    *)
        send_exit_error $INVALID_COMMAND
        ;;
esac
