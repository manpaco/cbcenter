#!/usr/bin/env bash

# ---------- NAMES -----------
mybasename="$(basename "$0")"
PROJECT="cbcenter"

#
# When using directory variables remember to add a trailing slash.
# For that reason, PDIR stands for (P)artial (DIR)ectory.
#
# ---------- FILES AND DIRECTORIES -----------
if ! [[ -d "${HOME:?HOME var is not assigned !}" ]]; then
    echo "HOME var is not valid !" 1>&2
    exit 1
fi
MYPATH="${HOME}/.local/$PROJECT"
MYCONFIG_PDIR="${HOME}/.config/$PROJECT"
MYCONFIG_FILE="${MYCONFIG_PDIR}/config"
DOWNLOADS_PDIR="${MYPATH}/downloads"
FAVORITES_PDIR="${MYPATH}/favorites"
FAVORITES_FILE="${FAVORITES_PDIR}.cb"
STREAMS_PDIR="${DOWNLOADS_PDIR}/streams"
CAPTURES_PDIR="${DOWNLOADS_PDIR}/captures"
# ----------- TEMP FILES AND DIRECTORIES -------------
TMP_PDIR="/tmp/$PROJECT"
SEARCH_FILE="${TMP_PDIR}/search.cb"
OTHERS_PDIR="${TMP_PDIR}/others"
OTHERS_FILE="${OTHERS_PDIR}.cb"
BIOCONTEXT_FILE="${TMP_PDIR}/biocontext.cb"
MORE_PDIR="${TMP_PDIR}/more"
MORE_FILE="${MORE_PDIR}.cb"
MOREWHO_FILE="${MORE_FILE}.who"
RANDOM_FILE="${TMP_PDIR}/random.cb"

# ----------- FORMATS ---------------
VIDEO_FORMAT="mp4"
IMG_FORMAT="jpg"
CODEC="h264"

# ----------- VIEWER ------------
VIEWER="imv -fd" # <<== I'm here!
OPEN_ENTIRE_DIR=1

# ----------- FETCH ------------
FETCH_TYPE="steps" # 'steps' or 'crazy'
FETCH_STEPS=10

#
# When using url variables remember to add a trailing slash (only when necessary).
# For that reason, PURL stands for (P)artial (URL).
#
# ------------ URLS -------------
PREVIEW_PURL="https://thumb.live.mmcdn.com/riw"
SEARCH_PURL="https://chaturbate.com/ax/search/?keywords=" # not necessary trailing slash
ROOMLIST_PURL="https://chaturbate.com/api/ts/roomlist/room-list"
BIOCONTEXT_PURL="https://chaturbate.com/api/biocontext"
MORELIST_PURL="https://chaturbate.com/api/more_like"
TOP_TAGS_PURL="https://chaturbate.com/api/ts/hashtags/top_tags"

# ------------ REGULAR EXPRESSIONS -------------
FEMALE_ROOM="f"
MALE_ROOM="m"
COUPLE_ROOM="c"
TRANS_ROOM="t"
ID_REGEX="[0-9]+"
CB_ROOT_PURL="https://www.chaturbate.com"
CAM_ROOT_REGEX="https:\/\/edge[0-9]+-[a-z]+\.live\.mmcdn\.com"
LIVE_PREFIX="live-"
LIVE_REGEX="${LIVE_PREFIX}(hls|edge)"
USER_PREFIX="amlst:"
USER_REGEX="[a-z0-9_]{3,30}"
USER_SUFFIX="-sd-"
CODE64="[0-9a-z]{64}"
CODE64_SUFFIX="_trns_"
PLAYLIST="playlist.m3u8"
LIVE_USER_REGEX="${LIVE_REGEX}\/${USER_PREFIX}${USER_REGEX}"
EXTRA_STUFF_REGEX="${USER_SUFFIX}${CODE64}${CODE64_SUFFIX}${CODEC}"
LOCATION_REGEX="${LIVE_USER_REGEX}${EXTRA_STUFF_REGEX}"
MINIMAL_CAM_REGEX="${CAM_ROOT_REGEX}\/${LIVE_USER_REGEX}"
COMPLETE_CAM_REGEX="${MINIMAL_CAM_REGEX}${EXTRA_STUFF_REGEX}\/${PLAYLIST}"
CHUNK_REGEX="chunklist_w[0-9]+_b[0-9]+_t[0-9a-zA-Z=]+\.m3u8"
PROG_REGEX="BANDWIDTH=[0-9]+,NAME=\"FPS:[0-9]+\.[0-9]+\",CODECS=\"[a-z0-9.,]*\",RESOLUTION=[0-9]+x[0-9]+"
GENDER_REGEX="${FEMALE_ROOM}|${MALE_ROOM}|${COUPLE_ROOM}|${TRANS_ROOM}"
FETCH_DIGITS_REGEX="[0-9]{1,2}"
MIN_AGE=18
MAX_AGE=99
TAG_REGEX="[a-z0-9]{2,30}"
KEYWORD_REGEX="[a-z0-9_]{2,30}" # TAG_REGEX union USER_REGEX

# ----------- TOOLS ------------
JQ_ONLINE="online"
JQ_OFFLINE="offline"
JQ_HASGTAGS="hashtags"
JQ_RLIST_MAIN="rooms"
JQ_MLIST_MAIN="${JQ_RLIST_MAIN}"
JQ_RLIST_USER="username"
JQ_MLIST_USER="room"
JQ_BIO_RSTATUS="room_status"
XRW_HEADER="X-Requested-With: XMLHttpRequest"
HTTP_NOT_FOUND_TEXT="404 Not Found"
HTTP_TOO_MANY_REQUESTS_TEXT="429 Too Many Requests"
CONNECT_TIMEOUT=10
CHECK_CONNECTION=0

# ----------- EXIT CODES -----------
OK_CODE=0
GENERIC_ERROR=1
GET_ERROR=2
PROCESSING_ERROR=3
FILESYS_ERROR=4
STORAGE_ERROR=5
HTTP_ERROR=6
CONNECTION_ERROR=7
VALUE_ERROR=8
# ---------- ROOM CODES -----------
NOT_PUBLIC_ROOM=20
ROOM_NOT_FOUND=21
BANNED_ROOM=22
OFFLINE_ROOM=23

# ------------ COLORS -------------
RED_FG="\033[0;31m"
GREEN_FG="\033[0;32m"
LIGHT_BLUE_FG="\033[1;34m"
YELLOW_FG="\033[1;33m"
CLEAR_FG="\033[0m"

# Return 0 if '$1' is a valid fetch type, else 1
# '$1' possible fetch type
valid_fetch_type () {
    [[ "$1" == "steps" || "$1" == "crazy" ]]
}

# Return 0 if '$1' is a valid configuration line, else 1
# '$1' possible configuration line
valid_config_line () {
    [[ "$1" =~ ^(FETCH_TYPE=\".+\")$ ]] ||
        [[ "$1" =~ ^(FETCH_STEPS=\".+\")$ ]] ||
        [[ "$1" =~ ^(VIEWER=\".+\")$ ]] ||
        [[ "$1" =~ ^(CHECK_CONNECTION=\".+\")$ ]] ||
        [[ "$1" =~ ^(OPEN_ENTIRE_DIR=\".+\")$ ]] ||
        [[ -z "$1" ]]
}

# Check configuration file line by line, and then 'source' it
check_and_source_config () {
    declare -i nline=1
    while IFS='' read -r rline; do
        if valid_config_line "$rline"; then
            echo "$rline"
        else
            echo -e "${RED_FG}Invalid config line $nline:${CLEAR_FG} '$rline'" 1>&2
        fi
        nline+=1
    done < "$MYCONFIG_FILE" > "${MYCONFIG_FILE}.checked" # only redirect stdout to checked config
    source "${MYCONFIG_FILE}.checked"
    rm "$MYCONFIG_FILE.checked"
}

# Confifure user variables
configure () {
    ! [[ -e "$MYCONFIG_FILE" ]] && return
    local def_ft="$FETCH_TYPE"
    local def_fs="$FETCH_STEPS"
    local def_cc="$CHECK_CONNECTION"
    local def_oed="$OPEN_ENTIRE_DIR"
    check_and_source_config
    if ! valid_fetch_type "$FETCH_TYPE"; then
        FETCH_TYPE="$def_ft"
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Invalid FETCH_TYPE value in config file! Using default '$def_ft'. ${YELLOW_FG}<--${CLEAR_FG}"
    fi
    if ! valid_id "$FETCH_STEPS"; then
        FETCH_STEPS="$def_fs"
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Invalid FETCH_STEPS value in config file! Using default '$def_fs'. ${YELLOW_FG}<--${CLEAR_FG}"
    else
        FETCH_STEPS="$(remove_leading_zeros "$FETCH_STEPS")"
        if [[ $FETCH_STEPS -eq 0 ]]; then
            FETCH_STEPS="$def_fs"
            echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: FETCH_STEPS value equal to 0 in config file! Using default '$def_fs'. ${YELLOW_FG}<--${CLEAR_FG}"
        fi
    fi
    if ! [[ "$CHECK_CONNECTION" =~ ^[0-1]$ ]]; then
        CHECK_CONNECTION="$def_cc"
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Invalid CHECK_CONNECTION value in config file! Using default '$def_cc'. ${YELLOW_FG}<--${CLEAR_FG}"
    fi
    if ! [[ "$OPEN_ENTIRE_DIR" =~ ^[0-1]$ ]]; then
        OPEN_ENTIRE_DIR="$def_oed"
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Invalid OPEN_ENTIRE_DIR value in config file! Using default '$def_oed'. ${YELLOW_FG}<--${CLEAR_FG}"
    fi
    if ! valid_command_string "$VIEWER"; then
        echo -e "\
    ${YELLOW_FG}-->${CLEAR_FG} Warning: Posible invalid VIEWER value in config file! Check the config. ${YELLOW_FG}<--${CLEAR_FG}"
    fi
}

# Check if a executable if found on PATH
# '$1' executable name
which_check () {
    echo -n "$1: "
    if which "$1" &>/dev/null; then
        echo "OK"
        return $OK_CODE
    else
        echo -e "${RED_FG}NOT FOUND${CLEAR_FG}"
        return $GENERIC_ERROR
    fi
}

# Check dependencies and show info on stdout
check_dependencies () {
    echo "Checking dependencies ..."
    which_check curl
    which_check wget
    which_check sed
    which_check jq
    which_check ffmpeg
    which_check ffplay
    echo "Use one of the following image viewers:"
    # If found exact match on the first "word"
    # (continuous characters without spaces) of viewer variable, then show 'using'
    local cd_viewer
    cd_viewer="$(trim_string "$VIEWER")"
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv-dir)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-dir
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv-x11)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-x11
    echo -n "  "; [[ "${cd_viewer%% *}" =~ ^(imv-wayland)$ ]] && echo -en "${LIGHT_BLUE_FG}using${CLEAR_FG} --> "; which_check imv-wayland
    echo "... or use what you want. See the help to know how to configure it."
}

# Show favorites limit suggestion
show_add_suggestion () {
    echo -e "${LIGHT_BLUE_FG}SUGGESTION:${CLEAR_FG} Do not add more than 10 favorites to avoid reaching the rate limit too soon."
}

# Show distribution warning
show_dist_warning () {
    echo -e "${RED_FG}CB_WARNING: Do not distribute content (from anywhere) without consent. Personal use only.${CLEAR_FG}"
}

# Show help block
# always call before 'configure' to show correct default values
show_help () {
    echo -e "\
Manage your favorite rooms from $CB_ROOT_PURL.

Usage:

  $mybasename COMMAND OPTION

Commands and options:

  a, add             [-f] username [username2 [... [usernameN]]]
                                 - Add new room(s) to favorites. If '-f' is
                                   provided do not check active(**) status.
  r, remove          [username]  - Remove one room from favorites.
  R, multi-remove                - Remove multiple rooms from favorites.
  ff, fetch-favorites      [-f]  - Fetch previews of favorite rooms. If '-f' is
                                   provided do not check global(*) status.
  vf, view-favorites             - Open fetched previews (favorites).
  lf, list-favorites  [-l] [-s]  - List of favorite rooms. If '-s' is provided
                                   show global(*) status. If '-l' is provided
                                   show position (line) on favorites file.
  rs, room-status    [-e] [username]
                                 - Show internal(*) status. If '-e' is provided
                                   return error if the room is not active(**).
  rp, room-programs  [username]  - Show available programs of given room.
  ri, room-info      [username]  - Show basic info.
  rb, room-bio       [username]  - Show biocontext.
  fo, fetch-others   [filters]   - Fetch previews of other rooms. See 'Filters'
                                   section.
  vo, view-others                - Open fetched previews (others).
  lo, list-others                - List of fetched rooms (others).
  fm, fetch-more     [username]  - Fetch previews of rooms like 'username'.
  vm, view-more                  - Open fetched previews (more).
  lm, list-more                  - List of fetched rooms (more).
  sc, save-capture   [username]  - Save a screenshot (high resolution).
  ss, save-stream    [username]  - Save stream of given room.
  ps, play-stream    [username]  - Play stream of given room.
  ks, keyword-search    keyword  - Search a keyword on the website.
  th, top-hashtags        count  - Get 'n' top hashtag(s).
  ra, random           [gender]  - Show preview of random room. If 'gender' is
                                   provided, only fetch 'gender' rooms.
  tn, thumbnail      [username]  - Show preview of given room.
  __clear_favorites              - Clear the 'favorites' directory.
  __clear_captures               - Clear the 'captures' directory.
  __clear_streams                - Clear the 'streams' directory.
  __clear_others                 - Clear the 'others' directory.
  __clear_more                   - Clear the 'more' directory.
  __clear_all
  __check_deps                   - Check program dependencies.
  __is_online          username  - Check global(*) status and return 0 if
                                   online, else 1. Does not check if the room
                                   is active(**).
  __favorites_file               - Show favorites file (path and name).
  h, help                        - This text.

(*) There are two types of room status:
    Global: non-detailed room status (less network usage).
            Possible values: online or offline.
    Internal: detailed room status.
              Possible values: public, private, hidden, away, or offline. If
              '-e' option is not provided, also: not found or banned.
    Therefore, \"online\" means that the room can be public, private, hidden,
    or away. On the other hand, \"offline\" could mean the room: is offline,
    not found (does not exist), or banned.
(**) An active room is one that EXISTS and is NOT BANNED.

TIP: If [username] is not provided, you will be asked to choose an option\n\
     from your favorites.

Configuration:

  Create a file called 'config' in directory '${MYCONFIG_PDIR}/' and use:

  VIEWER=\"<command>\"
    Replace <command> with whatever you want. e.g. VIEWER=\"gpicview\"
    Command used to open previews.
    DEFAULT: '$VIEWER'
  FETCH_TYPE=\"<type>\"
    Replace <type> with 'steps' or 'crazy'.
    steps: Fetch x rooms in each iteration until you obtain all of them.
    crazy: Fetch all the rooms at once.
    DEFAULT: '$FETCH_TYPE'
  FETCH_STEPS=\"<int>\"
    Replace <int> with an integer greater than 0.
    Number of rooms fetched in each iteration when user set FETCH_TYPE to 'steps'.
    Also used in 'limit' filter as fallback value.
    DEFAULT: '$FETCH_STEPS'
  CHECK_CONNECTION=\"<bool>\"
    Replace <bool> with a boolean integer, i.e. 1 or 0.
    Check connection to main page. If set to 0 ignore check.
    DEFAULT: '$CHECK_CONNECTION'
  OPEN_ENTIRE_DIR=\"<bool>\"
    Repalce <bool> with a boolean integer.
    Open entire directories with VIEWER. If set to 0 open the first file.
    DEFAULT: '$OPEN_ENTIRE_DIR'

  Comments and unnecessary spaces are not allowed. e.g. the following lines
  are not valid: '# Setting to 0 because...' or ' VIEWER=\"imv -fd\" '
                  ^ comment                      ^                ^
                                                 ^ unnecessary spaces
Filters:

  -g gender[,gender2[...[,genderN]]] --> gender(s): Gender of room users.
      'f' (female), 'm' (male), 'c' (couple), 't' (trans)
      example: -g c,t
      If none is provided, fetch mixed rooms.
  -o offset --> offset: Beginning room.
      Two digits (max) integer from 0 (or 00) to 99.
      If none is provided, the value 0 is taken.
  -l limit --> limit: Number of rooms.
      Two digits (max) integer from 1 (or 01) to 99.
      If none is provided, the value of FETCH_STEPS is taken.
  -f from --> from age
      Two digits (max) integer from $MIN_AGE to $MAX_AGE.
      Must be less (or equal) than 'to age'.
      examples: -f 20
  -t to --> to age
      Two digits (max) integer from $MIN_AGE to $MAX_AGE.
      Must be greater (or equal) than 'from age'.
      example: -t 30
  -r region[,region2[...[,regionN]]] --> region(s)
      AS (Asia), ER (Europe/Russia), NA (North America), SA (South America), O (Other).
      example: -r NA,SA,O
  -h hashtag[,hashtag2[...[,hashtagN]]] --> hashtag(s)
      example: -h hotkeys,bigbus,threadpool

TIP: You can set just one of the age filters and the other one will be setted to
     upper limit or lower limit to fullfill the filter 'from-to'.
     example: if yout set '-t 40' and do not set '-f' then it will be auto-setted
     to '-f $MIN_AGE'.

Directories and files:

  PROJECT DIR:   $MYPATH/
  CONFIG DIR:    $MYCONFIG_PDIR/
  CONFIG:        $MYCONFIG_FILE
  DOWNLOADS DIR: $DOWNLOADS_PDIR/
  FAVORITES DIR: $FAVORITES_PDIR/
  FAVORITES:     $FAVORITES_FILE
  TEMPORAL DIR:  $TMP_PDIR/
  MORE DIR:      $MORE_PDIR/
  OTHERS DIR:    $OTHERS_PDIR/
  BIOCONTEXT:    $BIOCONTEXT_FILE
  MORE:          $MORE_FILE
  MORE (who):    $MOREWHO_FILE
  OTHERS:        $OTHERS_FILE
  RANDOM:        $RANDOM_FILE
  SEARCH:        $SEARCH_FILE

FAQs:

  - What is a stream 'program'?
      A 'program' represent the video 'channel' or 'quality'. This channels
      are identified by ID, from '0' (lowest quality) to 'n' (highest quality).
      To get programs use 'room-programs' command. You can go to
      FFMPEG Documentation for more info.
  - What do the strange errors mean when I want to play/save/capture/fetch?
      You are probably being blocked by rate limiting.
      A rate limiting solution measures the amount of time between each
      request from each IP address, and also measures the number of
      requests within a specified timeframe. If there are too many
      requests from a single IP within the given timeframe, the rate
      limiting solution will not fulfill the IP address's requests for a
      certain amount of time.
  - How can I change the default image viewer for previews?
      Use VIEWER configuration variable. Remember to set OPEN_ENTIRE_DIR to 0
      if your viewer do not support open entire directories. See 'Configuration'
      section for more info.
  - Why are the rooms fetched in x at a time?
      To avoid reaching the rate limit too soon.
      Also you can change that value (or even disable the option) in 'config'
      file, see 'Configuration' section.
  - How can I change video quality when playing stream?
      Pres 'c' key to cycle stream 'programs'.
      See ffplay documentation for more info.
  - Where are saved the previews/captures/streams?
      Previews are saved in separated directories (others, more, and favorites).
      Captures and streams are saved in DOWNLOADS.
      See 'Directories and files' section.

Examples:

  - Add new rooms to favorites:
      $mybasename add bigkeys69 hot_port22 back_xz_door560
  - Fetch the first 10 female rooms:
      $mybasename fetch-others -g f -l 10
  - Fetch 30 (couples) rooms starting from 13th:
      $mybasename fetch-others -g c -l 30 -o 13
  - Fetch a (random) trans room:
      $mybasename random t
  - Fetch more rooms with a similar appearance and content:
      $mybasename fetch-more userhere"
}

# Send error message and exit program
# '$1' error code
send_exit_error () {
    unset IFS
    echo -n "$mybasename: error: " 1>&2
    case "$1" in
        "$GET_ERROR")
            shift
            echo "while getting ${*:-data}"
            exit $GET_ERROR
            ;;
        "$PROCESSING_ERROR")
            shift
            echo "while processing $*"
            exit $PROCESSING_ERROR
            ;;
        "$FILESYS_ERROR")
            shift
            echo "$*"
            exit $FILESYS_ERROR
            ;;
        "$STORAGE_ERROR")
            shift
            echo "$*"
            exit $STORAGE_ERROR
            ;;
        "$HTTP_ERROR")
            shift
            echo "server response $*" 1>&2
            exit $HTTP_ERROR
            ;;
        "$CONNECTION_ERROR")
            echo "the connection failed" 1>&2
            exit $CONNECTION_ERROR
            ;;
        "$VALUE_ERROR")
            shift
            echo -e "$*"
            exit $VALUE_ERROR
            ;;
        "$NOT_PUBLIC_ROOM")
            echo "the room is ${2:-not public}" 1>&2
            exit $NOT_PUBLIC_ROOM
            ;;
        "$ROOM_NOT_FOUND")
            echo "room not found" 1>&2
            exit $ROOM_NOT_FOUND
            ;;
        "$BANNED_ROOM")
            echo "the room is banned from the site" 1>&2
            exit $BANNED_ROOM
            ;;
        "$OFFLINE_ROOM")
            echo "the room is offline" 1>&2
            exit $OFFLINE_ROOM
            ;;
        *)
            shift
            echo -e "GENERIC_ERROR $*" 1>&2
            exit $GENERIC_ERROR
            ;;
    esac
}

# Wrap username using CB_ROOT_PURL
# '$1' username
wrap_username () {
    echo "${CB_ROOT_PURL}/$1/"
}

# Show search response on stdout
# '$1' keyword
curl_search () {
    curl -sL --compressed -H "$XRW_HEADER" "${SEARCH_PURL}$1"
}

# Alternative and simple global status checker
# With this approach if the rate limit is reached always return offline
alt_is_online () {
    curl_search "$1" | jq -Mc ".${JQ_ONLINE}" | grep -q "\"$1\""
    # You can add stderr redirection to hide jq errors in case of reaching
    # rate limit
    #curl_search "$1" | jq -Mc ".${JQ_ONLINE}" 2>/dev/null | grep -q "\"$1\""
}

# return 0 if online/private/hidden, else offline/error
# '$1' username
# '$2' return value when is not online.
is_online () {
    [[ -n "$2" ]] && declare -n io_out="$2"
    local cs_online
    if ! cs_online="$(curl_search "$1" | jq -Mc ".${JQ_ONLINE}" 2>/dev/null)"; then
        # shellcheck disable=SC2034
        io_out="error"
        return $GET_ERROR
    fi
    if ! echo "$cs_online" | grep -q "\"$1\""; then
        # shellcheck disable=SC2034
        io_out="offline"
        return $OFFLINE_ROOM
    fi
    return $OK_CODE
}

# Fetch biocontext and extract internal room status
# '$1' room
# '$2' stdout control
fetch_room_status () {
    if ! fetch_bio "$1"; then
        [[ "$2" == "hide" ]] || echo "error"
        return $GET_ERROR
    fi
    local frs_out
    if ! frs_out="$(jq -Mr ".${JQ_BIO_RSTATUS}" "$BIOCONTEXT_FILE" 2>/dev/null)";
    then
        [[ "$2" == "hide" ]] || echo "not found"
        return $ROOM_NOT_FOUND
    fi
    if [[ "$frs_out" == "null" ]]; then
        [[ "$2" == "hide" ]] || echo "banned"
        return $BANNED_ROOM
    fi
    [[ "$2" == "hide" ]] || echo "$frs_out"
    return $OK_CODE
}

# Store room_status field on '$2' from biocontext file (JSON)
# Also send exit error if the room: doesnt exist or is banned.
# '$1' room
# '$2' store room_status
assert_active_room () {
    if [[ -n "$2" ]]; then
        declare -n rs_out="$2"
        rs_out="$(fetch_room_status "$1")" || send_exit_error $?
        [[ -z "$rs_out" ]] && send_exit_error $GENERIC_ERROR "assert '-n \$rs_out'"
        return $OK_CODE
    fi
    fetch_room_status "$1" hide || send_exit_error $?
}

# return 0 if valid, else 1
# '$1' id
valid_id () {
    [[ "$1" =~ ^($ID_REGEX)$ ]]
}

# Extract programs from playlist data and show on stdout
# '$1' playlist data
show_programs () {
    declare -n sp_data="$1"
    declare -i sp_current=0
    echo "Available programs:"
    while [[ $sp_data =~ $PROG_REGEX ]]; do
        echo -e "\t${YELLOW_FG}PROG_ID=\"$sp_current\"${CLEAR_FG} - ${BASH_REMATCH[0]}"
        sp_data="${sp_data/${BASH_REMATCH[0]}/}"
        sp_current+=1
    done
}

# Get data from playlist and show on stdout
# '$1' room playlist
fetch_data () {
    curl -siL --compressed --connect-timeout "$CONNECT_TIMEOUT" "$1"
}

# Extract playlist from room page
# '$1' username
# '$2' store extracted playlist
extract_playlist () {
    declare -n ep_out="$2"
    local ep_cburl
    ep_cburl="$(wrap_username "$1")"
    local ep_page
    if ! ep_page="$(wget -4 -qS -O - "$ep_cburl" 2>&1)"; then
        [[ "$ep_page" =~ $HTTP_NOT_FOUND_TEXT ]] && send_exit_error $HTTP_ERROR "$HTTP_NOT_FOUND_TEXT"
        [[ "$ep_page" =~ $HTTP_TOO_MANY_REQUESTS_TEXT ]] && send_exit_error $HTTP_ERROR "$HTTP_TOO_MANY_REQUESTS_TEXT"
    fi
    ep_page="$(echo -e "$ep_page")"
    [[ "$ep_page" =~ $COMPLETE_CAM_REGEX ]] || send_exit_error $PROCESSING_ERROR "web page"
    ep_out="${BASH_REMATCH[0]}"
    [[ -z $ep_out ]] && send_exit_error $GENERIC_ERROR "assert '-n \$ep_out'"
    return $OK_CODE
}

# Extract direct link from playlist. Useful for speedup fetch process of save/capture streams.
# '$1' username
# '$2' store extracted link
extract_direct_link () {
    local dl_link
    extract_playlist "$1" dl_link
    declare -n dl_out="$2"
    local dl_prog
    dl_prog="$3"
    local dl_data
    dl_data="$(fetch_data "$dl_link")"
    [[ -z $dl_data ]] && send_exit_error $GET_ERROR "playlist data"
    if [[ -z $dl_prog ]]; then
        show_programs dl_data
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Select a program ID: "
        read -r dl_prog
        valid_id "$dl_prog" || send_exit_error $VALUE_ERROR "invalid program ID $dl_prog"
        dl_prog="$(remove_leading_zeros "$dl_prog")"
    fi
    local dl_chunk
    declare -i dl_current=0
    # Extract chunk from data (chunks are .m3u8 files for specific stream quality)
    # If user choice prog id 0, then first chunk is extracted (low quality stream)
    # For high quality stream, pass high prog id (e.g. 99)
    while [[ $dl_data =~ $CHUNK_REGEX ]] && [[ $dl_current -le $dl_prog ]]; do
        dl_chunk="${BASH_REMATCH[0]}"
        # Remove match from data
        dl_data="${dl_data/${BASH_REMATCH[0]}/}"
        dl_current+=1
    done
    [[ -z $dl_chunk ]] && send_exit_error $PROCESSING_ERROR "playlist data"
    local dl_root_locat
    # In some cases stream is located in another place than main playlist (_link)
    if [[ $dl_data =~ $LOCATION_REGEX ]]; then
        # If new location is found, replace it
        dl_root_locat="${dl_link%%"${LIVE_PREFIX}"*}${BASH_REMATCH[0]}"
    else
        # Else keep location and only remove '/playlist.m3u8' from '_link'
        dl_root_locat="${dl_link%/*}"
    fi
    dl_out="${dl_root_locat}/${dl_chunk}"
    [[ -z $dl_out ]] && send_exit_error $GENERIC_ERROR "assert '-n \$dl_out'"
    return $OK_CODE
}

# return 0 if valid, else 1
# '$1' username
valid_username () {
    [[ "$1" =~ ^($USER_REGEX)$ ]]
}

# Show formated date on stdout
formated_date () {
    date +%Y%m%d%H%M%S
}

# Print the number of lines
# '$1' file
line_count () {
    local lcount
    lcount="$(wc -l "$1" 2>/dev/null)"
    [[ -z "$lcount" ]] && echo 0 && return
    echo "${lcount%% *}"
}

# return 0 if room exists on favorites file, else 1
# '$1' room
stored_room () {
    grep -qx "$1" "$FAVORITES_FILE"
}

# Get favorite room from FAVORITES_FILE using line number
# '$1' line number
get_favorite_line () {
    sed "${1}q;d" "$FAVORITES_FILE"
}

# Remove line from FAVORITES_FILE
# '$1' line number
rem_favorite_line () {
    sed -i "${1:?Empty parameter !}d" "$FAVORITES_FILE" && echo "Done, removed!"
}

choice_message () {
    local wroom
    local echoi
    if [[ "$1" == "multi" ]]; then
        wroom="s"
        echoi="s separated by spaces"
    fi
    echo "  Which room$wroom do you want to ${2:-choose}?"
    echo -en "${YELLOW_FG}==>${CLEAR_FG} Enter your choice$echoi, or (Q)uit: "
}

# Ask the user for a choice, and store the choice on '$1'. If '$2' is other
# than 'hide_list', then show favorites list (with line numbers).
# '$1' store choice
# '$2' hide_list
# '$3' custom action (string after "Which room do you want to...")
favorite_choice () {
    declare -n fc_out="$1"
    [[ $2 == "hide_list" ]] || list_favorites -l
    choice_message single "$3"
    read -r fc_out
    [[ $fc_out == [qQ] || -z "$fc_out" ]] && exit $OK_CODE
    valid_id "$fc_out" || send_exit_error $VALUE_ERROR "non-numeric choice $fc_out"
    fc_out="$(remove_leading_zeros "$fc_out")"
    [[ "$fc_out" -lt 1 ]] && send_exit_error $VALUE_ERROR "choice $fc_out is out of range"
    [[ "$fc_out" -gt "$(line_count "$FAVORITES_FILE")" ]] &&
        send_exit_error $VALUE_ERROR "choice $fc_out is out of range"
}

# Uses FAVORITES_FILE
# The same as 'favorite_choice' but store username on '$1'.
# '$1' store username
# '$2' hide_list
# '$3' custom target (string after "Which room do you want to...")
favorite_room_choice () {
    declare -n frc_out="$1"
    local frc_choice
    favorite_choice frc_choice "$2" "$3"
    frc_out="$(get_favorite_line "$frc_choice")"
    [[ -z $frc_out ]] && send_exit_error $GENERIC_ERROR "assert '-n \$frc_out'"
}

# Get the username from OTHERS_FILE using an index
# '$1' index
get_other_by_index () {
    jq -Mre ".${JQ_RLIST_MAIN}[${1:?}].${JQ_RLIST_USER}" "$OTHERS_FILE"
}

# Get the username from MORE_FILE using an index
# '$1' index
get_more_by_index () {
    jq -Mre ".${JQ_MLIST_MAIN}[${1:?}].${JQ_MLIST_USER}" "$MORE_FILE"
}

# Print the number of 'other' rooms
other_rooms_count () {
    local orc_count
    orc_count="$(jq -e ".${JQ_RLIST_MAIN} | length" "$OTHERS_FILE" 2>/dev/null)"
    [[ -z "$orc_count" ]] && echo 0
    echo "$orc_count"
}

# Print the number of 'more' rooms
more_rooms_count () {
    local mrc_count
    mrc_count="$(jq -e ".${JQ_MLIST_MAIN} | length" "$MORE_FILE" 2>/dev/null)"
    [[ -z "$mrc_count" ]] && echo 0
    echo "$mrc_count"
}

# Show list of other rooms with line number
list_others () {
    declare -i num_rooms
    num_rooms="$(other_rooms_count)"
    [[ $num_rooms -eq 0 ]] && send_exit_error $STORAGE_ERROR "empty room list"
    echo "List of 'other' rooms:"
    for ((i = 0 ; i < num_rooms ; i++)); do
        echo "$i:$(get_other_by_index "$i")"
    done
}

# Show list of more rooms with line number
list_more () {
    declare -i num_rooms
    num_rooms="$(more_rooms_count)"
    [[ $num_rooms -eq 0 ]] && send_exit_error $STORAGE_ERROR "empty room list"
    echo "List of 'more-like' rooms:"
    for ((i = 0 ; i < num_rooms ; i++)); do
        echo "$i:$(get_more_by_index "$i")"
    done
}

# Remove leading zeros from '$1' and print result
# '$1' to check
remove_leading_zeros () {
    [[ -z "$1" ]] && return $GENERIC_ERROR
    [[ "$1" =~ ^0+$ ]] && echo 0 && return $OK_CODE
    echo "${1#"${1%%[!0]*}"}"
}

# Uses OTHERS_FILE
# Ask the user for a choice, and store the username on '$1'
# '$1' store username
# '$2' hide_list
# '$3' custom action (string after "Which room do you want to...")
other_room_choice () {
    declare -n orc_out="$1"
    local orc_choice
    [[ $2 == "hide_list" ]] || list_others
    choice_message single "$3"
    read -r orc_choice
    [[ $orc_choice == [qQ] || -z "$orc_choice" ]] && exit $OK_CODE
    valid_id "$orc_choice" || send_exit_error $VALUE_ERROR "non-numeric choice $mrc_choice"
    orc_choice="$(remove_leading_zeros "$orc_choice")"
    [[ "$((orc_choice+1))" -gt "$(other_rooms_count)" ]] &&
        send_exit_error $VALUE_ERROR "choice $orc_choice is out of range"
    orc_out="$(get_other_by_index "$orc_choice")"
    [[ -z $orc_out ]] && send_exit_error $GENERIC_ERROR "assert '-n \$orc_out'"
}

# Uses MORE_FILE
# Ask the user for a choice, and store the username on '$1'
# '$1' store username
# '$2' hide_list
# '$3' custom action (string after "Which room do you want to...")
more_room_choice () {
    declare -n mrc_out="$1"
    local mrc_choice
    [[ $2 == "hide_list" ]] || list_more
    choice_message single "$3"
    read -r mrc_choice
    [[ $mrc_choice == [qQ] || -z "$mrc_choice" ]] && exit $OK_CODE
    valid_id "$mrc_choice" || send_exit_error $VALUE_ERROR "non-numeric choice $mrc_choice non-numeric"
    mrc_choice="$(remove_leading_zeros "$mrc_choice")"
    [[ "$((mrc_choice+1))" -gt "$(more_rooms_count)" ]] &&
        send_exit_error $VALUE_ERROR "choice $mrc_choice is out of range"
    mrc_out="$(get_more_by_index "$mrc_choice")"
    [[ -z $mrc_out ]] && send_exit_error $GENERIC_ERROR "assert '-n \$mrc_out'"
}

# Add new rooms to favorites
# '$1' room
add_rooms () {
    local ignore_check=false
    [[ "$1" == "-f" ]] && ignore_check=true
    shift
    [[ -z "$*" ]] && send_exit_error $VALUE_ERROR "none username provided"
    for a in "$@"; do
        if ! valid_username "$a"; then
            echo -e "'$a' ${RED_FG}-->${CLEAR_FG} invalid username."
            continue
        fi
        if stored_room "$a"; then
            echo -e "'$a' ${RED_FG}-->${CLEAR_FG} already in favorites."
            continue
        fi
        local ar_status
        if ! $ignore_check && ! ar_status="$(fetch_room_status "$a")"; then
            echo -e "'$a' ${RED_FG}-->${CLEAR_FG} $ar_status"
            continue
        fi
        echo "$a" >> "$FAVORITES_FILE" && echo -e "'$a' ${LIGHT_BLUE_FG}added${CLEAR_FG}!${ar_status:+ The room is $ar_status}"
    done
}

# Add new room to favorites
# '$1' room
add_room () {
    echo "Adding $1 to favorites ..."
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    stored_room "$1" && send_exit_error $STORAGE_ERROR "the room already exists in the favorites list"
    local ar_status
    assert_active_room "$1" ar_status
    echo "$1" >> "$FAVORITES_FILE" && echo "Favorite added! The room is $ar_status"
}

# Remove room from favorites
# '$1' room
remove_room () {
    if [[ -z "$1" ]]; then
        local rr_choice
        favorite_choice rr_choice show_list remove
        rem_favorite_line "$rr_choice"
        return $OK_CODE
    fi
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    echo "Removing $1 room from favorites ..."
    local match
    if match="$(grep -xn "$1" "$FAVORITES_FILE")"; then # Exact match
        rem_favorite_line "${match%%:*}"
    else # Search partial matches
        # Use '-n' option on grep to use line numbers as choices if partial matches found
        match="$(grep -n "$1" "$FAVORITES_FILE")"
        [[ -z $match ]] && send_exit_error $STORAGE_ERROR "the room does not exists in the favorites list"
        echo "No exact match found!"
        echo "$match"
        local rr_choice
        favorite_choice rr_choice hide_list remove
        # Validate choice
        if echo "$match" | grep -q -E "^($rr_choice:)" -; then
            rem_favorite_line "$rr_choice"
        else
            send_exit_error $VALUE_ERROR "choice $rr_choice not match"
        fi
    fi
}

# Return 0 if '$1' is empty, else 1
# '$1' directory
empty_dir () {
    [[ "$(file_count "$1")" -eq 0 ]]
}

# Clear favorites directory
clear_favorites_dir () {
    if rm -f "${FAVORITES_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory FAVORITES deleted!"
    else
        echo -n "  "; echo -e "An ${RED_FG}error${CLEAR_FG} occurred while clearing FAVORITES!"
    fi
}

# Clear captures directory
clear_captures_dir () {
    if rm -f "${CAPTURES_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory CAPTURES deleted!"
    else
        echo -n "  "; echo -e "An ${RED_FG}error${CLEAR_FG} occurred while clearing CAPTURES!"
    fi
}

# Clear streams directory
clear_streams_dir () {
    if rm -f "${STREAMS_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory STREAMS deleted!"
    else
        echo -n "  "; echo -e "An ${RED_FG}error${CLEAR_FG} occurred while clearing STREAMS!"
    fi
}

# Clear rooms directory
clear_others_dir () {
    if rm -f "${OTHERS_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory OTHERS deleted!"
    else
        echo -n "  "; echo -e "An ${RED_FG}error${CLEAR_FG} occurred while clearing OTHERS!"
    fi
}

# Get preview and save it in given file
# '$1' username
# '$2' file
save_preview_in () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" -o "$2"
}

# Get preview and save it in given directory with predefined prefix (custom prefix is optional)
# '$1' username
# '$2' directory
# '$3' custom prefix (optional)
save_preview () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" -o "${2}/$3$(formated_date)-$1.$IMG_FORMAT"
}

# Get preview and show it using image viewer (not save file)
show_preview () {
    curl -sL --compressed -H "$XRW_HEADER" --connect-timeout "$CONNECT_TIMEOUT" "${PREVIEW_PURL}/$1.$IMG_FORMAT" | $VIEWER -
}

# Print number of files on a directory
# '$1' directory
file_count () {
    find "$1" -maxdepth 1 -type f | wc -l
}

# fetch_favorite_rooms helper
# save preview of '$1' on FAVORITES_PDIR: if success print 'fetched',
# else 'error'. If it is offline print 'offline'.
# '$1' VALID username
# '$2' line prefix
# '$3' force_fetch
ffr_helper () {
    [[ "$3" == "true" || "$3" == "false" ]] || return $GENERIC_ERROR
    local ffr_aux
    if $3 || is_online "$1" ffr_aux; then
        local prefix
        [[ $2 -lt 10 ]] && prefix="0$2" || prefix="$2"
        save_preview "$1" "$FAVORITES_PDIR" "$prefix" && echo -e "$2:$1 ${GREEN_FG}fetched${CLEAR_FG}" && return $OK_CODE
        echo -e "$2:$1 ${RED_FG}error${CLEAR_FG}"
        return $GENERIC_ERROR
    fi
    if [[ "$ffr_aux" == "offline" ]]; then
        echo "$2:$1 $ffr_aux"
    else
        echo -e "$2:$1 ${YELLOW_FG}${ffr_aux}${CLEAR_FG}"
    fi
}

# Show information when use '-f' option in 'fetch_favorite_rooms'
show_force_info () {
    echo -e "\
${GREEN_FG}INFO:${CLEAR_FG} When using the '-f' option you will probably get previews of rooms that are offline.\n\
  This is because the servers store the last preview for a few hours after going offline."
}

# Get previews of favorites (online only)
fetch_favorite_rooms () {
    echo "Fetching favorite rooms ..."
    show_fetch_message
    clear_favorites_dir
    local rvar

    local force_fetch=false
    if [[ "$1" == "-f" ]]; then
        force_fetch=true
        show_force_info
    fi

    # Crazy implementation
    if [[ "$FETCH_TYPE" == "crazy" ]]; then
        declare -i line=1
        local room
        while IFS="" read -r room || [ -n "$room" ]
        do
            ffr_helper "$room" "$line" "$force_fetch" &
            line+=1
        done < "$FAVORITES_FILE"
        wait
        # Ask to show fetched previews
        local rvar
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] &&
            open_favorites_dir
        return $OK_CODE
    fi

    # Steps implementation
    declare -i line=1
    local old_count
    old_count=0
    local current_count
    local room
    # Read file descriptor 3 (-u 3)
    # That allows us to use 'read' inside the while
    # without an unexpected behavior
    # The problem happens when 'read' is used inside 'read'
    while IFS="" read -u 3 -r room || [ -n "$room" ]; do
        ffr_helper "$room" "$line" "$force_fetch" &
        if [[ $((line%FETCH_STEPS)) -eq 0 ]]; then
            wait
            current_count="$(file_count "${FAVORITES_PDIR}/")"
            if [[ $current_count -ne $old_count ]]; then
                old_count="$current_count"
                echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
                read -r rvar
                [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] &&
                    open_favorites_dir
            fi
            echo -en "${YELLOW_FG}==>${CLEAR_FG} Continue fetching? (Y/n): "
            read -r rvar
            [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] ||
                break
        fi
        line+=1
    done 3< "$FAVORITES_FILE" # Send to file descriptor 3
    wait
    current_count="$(file_count "${FAVORITES_PDIR}/")"
    if [[ $current_count -ne $old_count ]]; then
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] &&
            open_favorites_dir
    fi
}

# Ask to the user to play stream
# '$1' room
ask_to_play () {
    local rplay
    echo -en "${YELLOW_FG}==>${CLEAR_FG} Do you want to play '$1' stream? (Y/n): "
    read -r rplay
    [[ $rplay == [yY] || $rplay == [yY][eE][sS] || -z $rplay ]] || return $OK_CODE
    play_room "$1"
}

# Get and show preview of given room
# '$1' username
quick_thumb () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    echo "Fetching thumbnail from $1 room ..."
    show_preview "$1"
    echo "  $1's room was fetched. Enjoy!"
    ask_to_play "$1"
}

# Open favorites directory
open_favorites_dir () {
    empty_dir "${FAVORITES_PDIR}/" && send_exit_error $FILESYS_ERROR "${FAVORITES_PDIR}/ directory is empty"
    if [[ $OPEN_ENTIRE_DIR -eq 1 ]]; then
        $VIEWER "$FAVORITES_PDIR"
    else
        local ffiles
        # shellcheck disable=SC2206
        # Quote to prevent word splitting/globbing,
        # or split robustly with mapfile or read -a:
        #read -r -a array <<< "$var"
        ffiles=($FAVORITES_PDIR/*)
        $VIEWER "${ffiles[0]}"
    fi
}

# Make sure the room is public, else exit program with an error
# '$1' room
assert_public_room () {
    local apr_status
    assert_active_room "$1" apr_status
    [[ "$apr_status" == "public" ]] && return $OK_CODE
    [[ "$apr_status" == "offline" ]] && send_exit_error $OFFLINE_ROOM
    #[[ "$apr_status" == "null" ]] && send_exit_error $NOT_PUBLIC_ROOM banned
    send_exit_error $NOT_PUBLIC_ROOM "$apr_status"
}

# Play room stream
# '$1' room
play_room () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    assert_public_room "$1"
    echo "Wait while resources are obtained ..."
    local pr_link
    extract_playlist "$1" pr_link
    ffplay -i "$pr_link"
}

# Save room stream
# '$1' room
save_room () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    assert_public_room "$1"
    echo "Wait while resources are obtained ..."
    local sr_link
    extract_direct_link "$1" sr_link
    local output
    output="${STREAMS_PDIR}/$(formated_date)-$1.$VIDEO_FORMAT"
    ffmpeg -i "$sr_link" -codec copy "$output"

    # Another way (slower ffmpeg startup)
    #local sr_link
    #extract_playlist "$1" sr_link
    #ffmpeg -i "$sr_link" -map v:p:$room_prog -map a:p:$room_prog -codec copy "$output"
}

# Save room screenshot
# '$1' room
save_capture () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    assert_public_room "$1"
    echo "Wait while resources are obtained ..."
    local sc_link
    extract_direct_link "$1" sc_link 99
    local output
    output="${CAPTURES_PDIR}/$(formated_date)-$1.$IMG_FORMAT"
    ffmpeg -i "$sc_link" -frames:v 1 -update true "$output"
}

# Show room programs
# '$1' room
room_programs () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    assert_public_room "$1"
    echo "Looking for programs ..."
    local rp_link
    extract_playlist "$1" rp_link
    local rp_data
    rp_data="$(fetch_data "$rp_link")"
    [[ -z $rp_data ]] && send_exit_error $GET_ERROR "playlist data"
    show_programs rp_data
}

# Return 0 if '$1' is a valid keyword, else 1
# '$1' string
valid_keyword () {
    [[ "$1" =~ ^($KEYWORD_REGEX)$ ]]
}

# Search given keyword
# '$1' keyword
keyword_search () {
    valid_keyword "$1" || send_exit_error $VALUE_ERROR "invalid keyword $1"
    curl_search "$1" > "$SEARCH_FILE" || send_exit_error $GET_ERROR "search"
    echo "Online rooms:"
    jq -e ".${JQ_ONLINE}" "$SEARCH_FILE" 2>/dev/null || send_exit_error $PROCESSING_ERROR "json search"
    echo "Recently online rooms:"
    jq -M ".${JQ_OFFLINE}" "$SEARCH_FILE"
    echo "Hashtags:"
    jq -M ".${JQ_HASGTAGS}" "$SEARCH_FILE"
}

# Show room status
# Only show online or offline (not the same as 'internal_status' function)
global_status () {
    local gs_aux
    if is_online "$1" gs_aux; then
        echo -e "${2:+$2:}$1 ${LIGHT_BLUE_FG}online${CLEAR_FG}"
    else
        if [[ "$gs_aux" == "offline" ]]; then
            echo "${2:+$2:}$1 $gs_aux"
        else
            echo -e "${2:+$2:}$1 ${YELLOW_FG}${gs_aux}${CLEAR_FG}"
        fi
    fi
}

# Show favorites on stdout
# '$1' show global status (-s)
# '$2' show line numbers (-l)
list_favorites () {
    echo "List of 'favorite' rooms:"
    declare -i line=1
    local laux
    local room
    while IFS="" read -r room || [ -n "$room" ]
    do
        if [[ $1 == "-l" || $2 == "-l" ]]; then
            laux="$line"
        else
            laux=""
        fi
        if [[ $1 == "-s" || $2 == "-s" ]]; then
            global_status "$room" "$laux" &
        else
            echo "${laux:+$laux:}$room"
        fi
        line+=1
    done < "$FAVORITES_FILE"
    wait
}

# Open others directory
open_others_dir () {
    empty_dir "${OTHERS_PDIR}/" && send_exit_error $FILESYS_ERROR "${OTHERS_PDIR}/ directory is empty"
    if [[ $OPEN_ENTIRE_DIR -eq 1 ]]; then
        $VIEWER "$OTHERS_PDIR"
    else
        local ofiles
        # shellcheck disable=SC2206
        # Quote to prevent word splitting/globbing,
        # or split robustly with mapfile or read -a:
        #read -r -a array <<< "$var"
        ofiles=($OTHERS_PDIR/*)
        $VIEWER "${ofiles[0]}"
    fi
}

# Save rooms list from given range on '$4' file.
# '$1' offset
# '$2' limit
# '$3' extra parameters (&key1=value1&key2=value2...&keyN=valueN)
# '$4' output
fetch_roomlist_file () {
    curl -sL --compressed -H "$XRW_HEADER" "$ROOMLIST_PURL/?offset=$1&limit=$2&enable_recommendations=false$3" -o "$4"
}

# Show fetch type and tip.
show_fetch_message () {
    echo -n "  "; echo "Using '${FETCH_TYPE}' fetch type."
    echo -e "${YELLOW_FG}TIP:${CLEAR_FG} Go back in the image viewer to see the most recent ones."
}

# fetch_rooms_using helper
# save preview of '$1' on '$3': if success print 'fetched', else 'error'
# '$1' username
# '$2' index prefix
# '$3' dest dir
fru_helper () {
    local prefix
    [[ $2 -lt 10 ]] && prefix="0$2" || prefix="$2"
    save_preview "$1" "$3" "$prefix" && echo "$2:$1 fetched" && return $OK_CODE
    echo -e "$2:$1 ${RED_FG}error${CLEAR_FG}"
    return $GENERIC_ERROR
}

# This abstract function avoids duplicate code.
# But it is probably easier to understand by dividing this function for each
# particular case (room-list and more-list).
# 'room-list' is obtained with fetch_roomlist_file
# 'more-list' is obtained with fetch_morelist_file
# Takes a 'room-list' or 'more-list' from '${1}' file and fetch all.
# '$1' name of json file. Also it is used to extract PDIR taking into account
#      that: e.g. OTHERS_FILE="${OTHERS_PDIR}.cb"
# '$2' main array
# '$3' json field inside main array (used to fetch preview)
# '$4' function name to clear dir
# '$5' function name to open dir
fetch_rooms_using () {
    local fru_file
    fru_file="$1"
    local fru_main
    fru_main="$2"
    local fru_user
    fru_user="$3"
    local fru_clear
    fru_clear="$4"
    local fru_open
    fru_open="$5"
    declare -i num_rooms
    num_rooms="$(jq -e ".$fru_main | length" "$fru_file" 2>/dev/null)" ||
        send_exit_error $PROCESSING_ERROR "json data"
    [[ $num_rooms -eq 0 ]] && send_exit_error $STORAGE_ERROR "empty room list"
    $fru_clear

    local room
    local rvar

    # Implementation to go crazy (without steps)
    if [[ "$FETCH_TYPE" == "crazy" ]]; then
        for ((i = 0 ; i < num_rooms ; i++)); do
            room="$(jq -Mre ".${fru_main}[$i].$fru_user" "$fru_file")"
            fru_helper "$room" "$i" "${fru_file%.*}" &
        done
        wait
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] &&
            $fru_open
        return $OK_CODE
    fi

    # Default implementation with steps (FETCH_STEPS at a time)
    declare -i index=0
    while true; do
        # Fetch room previews by 'FETCH_STEPS' at time
        while room="$(jq -Mre ".${fru_main}[$index].$fru_user" "$fru_file")"; do
            fru_helper "$room" "$index" "${fru_file%.*}" &
            index+=1
            [[ $((index%FETCH_STEPS)) -ne 0 ]] || break
        done
        wait
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Open previews? (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] && $fru_open
        [[ $index -eq $num_rooms ]] && break # There are no remaining rooms
        echo -en "${YELLOW_FG}==>${CLEAR_FG} Continue fetching? $((num_rooms-index)) remaining (Y/n): "
        read -r rvar
        [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] || break
    done
}

valid_tag () {
    [[ "$1" =~ ^($TAG_REGEX)$ ]]
}

# Return 0 if '$1' is a valid region, else 1
# '$1' possible region
valid_region () {
    [[ "$1" == "AS" ]] ||
        [[ "$1" == "ER" ]] ||
        [[ "$1" == "NA" ]] ||
        [[ "$1" == "SA" ]] ||
        [[ "$1" == "O" ]]
}

# Only keep one copy of the pattern when consecutive repetitions are found
# example: $1='a,,bb,ccc,,,,dddd,,' and $2=','
#          output --> 'a,bb,ccc,dddd,'
# '$1' string
# '$2' pattern
unify_consecutive_reps () {
    shopt -s extglob
    echo "${1//+(,)/,}"
}

# Return 0 if '$1' has 1 or 2 digits, else 1
# '$1' to probe
valid_fetch_digits () {
    [[ "$1" =~ ^($FETCH_DIGITS_REGEX)$ ]]
}

# Sort an array
# '$1' array
# '$2' reverse
# '$3' uniques
# '$4' numbers
sort_array () {
    declare -n sa_out="${1?:$mybasename: sort_array error: empty parameter}"

    local revparam
    [[ "$2" == "true" ]] && revparam=r
    local uniparam
    [[ "$3" == "true" ]] && uniparam=u
    local numparam
    [[ "$4" == "true" ]] && numparam=n

    # Sort (reverse -r) and keep unique (-u) numbers (-n).
    # Using here-string ( <<< ), process substitution ( <(command) ), and
    # output redirection ( < ). Finally store in array with readarray
    readarray -t sa_out < <(IFS=$'\n'; sort -${revparam}${uniparam}${numparam} <<<"${sa_out[*]}")
}

# Get and show rooms from given range
# '$1' offset
# '$2' limit
# '$3' gender(s)
# '$4' from age
# '$5' to age
# '$6' region(s)
# '$7' hashtag(s)
fetch_other_rooms () {
    local offset="$1"
    if [[ -n "$offset" ]]; then
        valid_fetch_digits "$offset" || send_exit_error $VALUE_ERROR "invalid offset $offset"
        offset="$(remove_leading_zeros "$offset")"
    else
        offset=0
    fi
    local limit="$2"
    if [[ -n "$limit" ]]; then
        valid_fetch_digits "$limit" || send_exit_error $VALUE_ERROR "invalid limit $limit"
        limit="$(remove_leading_zeros "$limit")"
        [[ $limit -eq 0 ]] && send_exit_error $VALUE_ERROR "limit equal to 0"
    else
        limit="$FETCH_STEPS"
    fi
    local xtras
    local genders="$3"
    if [[ -n "$genders" ]]; then
        genders="$(unify_consecutive_reps "$genders" ,)"
        genders="${genders#,}"
        genders="${genders%,}"
        declare -a garr
        IFS=","
        # check genders
        for g in $genders; do
            valid_gender "$g" || send_exit_error $VALUE_ERROR "invalid gender $g"
            garr+=("$g")
        done
        sort_array garr false true false
        xtras+="&genders=${garr[*]}"
        genders="${garr[*]}"
        unset IFS
    fi
    local from_age="$4"
    if [[ -n "$from_age" ]]; then
        valid_fetch_digits "$from_age" || send_exit_error $VALUE_ERROR "invalid 'from age' value $from_age"
        from_age="$(remove_leading_zeros "$from_age")"
        [[ $from_age -ge $MIN_AGE && $from_age -le $MAX_AGE ]] ||
            send_exit_error $VALUE_ERROR "'from age' ($from_age) is out of range"
    fi
    local to_age="$5"
    if [[ -n "$to_age" ]]; then
        valid_fetch_digits "$to_age" || send_exit_error $VALUE_ERROR "invalid 'to age' value $to_age"
        to_age="$(remove_leading_zeros "$to_age")"
        [[ $to_age -ge $MIN_AGE && $to_age -le $MAX_AGE ]] ||
            send_exit_error $VALUE_ERROR "'to age' ($to_age) is out of range"
    fi
    if [[ -z "$from_age" && -n "$to_age" ]]; then
        from_age="$MIN_AGE"
    elif [[ -z "$to_age" && -n "$from_age" ]]; then
        to_age="$MAX_AGE"
    fi
    if [[ -n "$from_age" && -n "$to_age" ]]; then
        [[ $from_age -gt $to_age ]] &&
            send_exit_error $VALUE_ERROR "'from age' ($from_age) is greater than 'to age' ($to_age)"
        xtras+="&ages=$from_age-$to_age"
        # They also specify 'from_age' and 'to_age'
        # If I not specify this two, wrong roomlist is fetched.
        xtras+="&from_age=$from_age"
        # xtras+="&to_age=$to_age" # intuitive way but not correct, so...
        # ... they do this in the page script:
        xtras+="&to_age=$((to_age+1))"
    fi
    local regions="$6"
    if [[ -n "$regions" ]]; then
        regions="$(unify_consecutive_reps "$regions" ,)"
        regions="${regions#,}"
        regions="${regions%,}"
        declare -a rarr
        IFS=","
        # check regions
        for r in $regions; do
            valid_region "$r" || send_exit_error $VALUE_ERROR "invalid region $r"
            rarr+=("$r")
        done
        sort_array rarr false true false
        xtras+="&regions=${rarr[*]}"
        regions="${rarr[*]}"
        unset IFS
    fi
    local hashtags="$7"
    if [[ -n "$hashtags" ]]; then
        hashtags="$(unify_consecutive_reps "$hashtags" ,)"
        hashtags="${hashtags#,}"
        hashtags="${hashtags%,}"
        declare -a harr
        IFS=","
        # check hashtags
        for h in $hashtags; do
            valid_tag "$h" || send_exit_error $VALUE_ERROR "invalid hashtag $h"
            harr+=("$h")
        done
        sort_array harr false true false
        xtras+="&hashtags=${harr[*]}"
        hashtags="${harr[*]}"
        unset IFS
    fi

    echo -e "Fetching $limit ${genders:-mixed} room(s) at $offset offset ..."
    [[ -n "$from_age" ]] && echo "    from $from_age to $to_age years"
    [[ -n "$regions" ]] && echo "    in $regions region(s)"
    [[ -n "$hashtags" ]] && echo "    with $hashtags hashtag(s)"
    fetch_roomlist_file "$offset" "$limit" "$xtras" "$OTHERS_FILE" || send_exit_error $GET_ERROR "room list"
    show_fetch_message
    echo -e "${GREEN_FG}INFO:${CLEAR_FG} Sometimes promoted rooms appear or the request cannot be filled due to filters.\n\
For this reason, it is possible that more (or less) than $limit rooms will be obtained."

    fetch_rooms_using "$OTHERS_FILE" "$JQ_RLIST_MAIN" "$JQ_RLIST_USER" clear_others_dir open_others_dir
}

# Save biocontext of given room
# '$1' room
fetch_bio () {
    curl -sL --compressed -H "$XRW_HEADER" "${BIOCONTEXT_PURL}/$1" -o "$BIOCONTEXT_FILE"
}

# Show basic info using biocontext
# '$1' room
room_info () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    assert_active_room "$1" # it calls fetch_bio
    echo -n "Real name: "
    jq -M '.real_name' "$BIOCONTEXT_FILE"
    echo -n "Location: "
    jq -M '.location' "$BIOCONTEXT_FILE"
    echo -n "Sex: "
    jq -M '.sex' "$BIOCONTEXT_FILE"
    echo -n "Age: "
    jq -M '.display_age' "$BIOCONTEXT_FILE"
    echo -n "Languages: "
    jq -M '.languages' "$BIOCONTEXT_FILE"
    echo -n "Room status: "
    jq -M ".${JQ_BIO_RSTATUS}" "$BIOCONTEXT_FILE"
    echo -n "Last stream: "
    jq -M '.time_since_last_broadcast' "$BIOCONTEXT_FILE"
}

# Show biocontext
# '$1' room
room_bio () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    assert_active_room "$1" # it calls fetch_bio
    jq . "$BIOCONTEXT_FILE"
}

# 0 if '$1' is a valid 'gender' on the site, else 1
valid_gender () {
    [[ "$1" =~ ^($GENDER_REGEX)$ ]]
}

# Show random preview using a custom range ('$1':RANDOM:1 or RANDOM:RANDOM:1 if '$1' is empty)
# '$1' gender
quick_rand () {
    local genders
    genders="$1"
    declare -a garr
    if [[ -n "$genders" ]]; then
        genders="${genders// /}"
        genders="$(unify_consecutive_reps "$genders" ,)"
        genders="${genders#,}"
        genders="${genders%,}"
        IFS=","
        # check genders
        for g in $genders; do
            valid_gender "$g" || send_exit_error $VALUE_ERROR "invalid gender $g"
            garr+=("$g")
        done
        sort_array garr false true false
        unset IFS
    fi
    local finalg
    if [[ "${#garr[@]}" -eq 0 ]]; then
        case $((RANDOM%4)) in
            0) finalg=$FEMALE_ROOM
                ;;
            1) finalg=$MALE_ROOM
                ;;
            2) finalg=$COUPLE_ROOM
                ;;
            3) finalg=$TRANS_ROOM
                ;;
        esac
    elif [[ "${#garr[@]}" -gt 1 ]]; then
        numg="${#garr[@]}"
        finalg="${garr[$((RANDOM%numg))]}"
    else
        finalg="${garr[0]}"
    fi
    echo "Fetching random room ..."
    fetch_roomlist_file $((RANDOM%100)) 1 "&genders=$finalg" "$RANDOM_FILE" || send_exit_error $GET_ERROR "room list"
    local room
    room="$(jq -Mre ".${JQ_RLIST_MAIN}[0].${JQ_RLIST_USER}" "$RANDOM_FILE" 2>/dev/null)" ||
        send_exit_error $PROCESSING_ERROR "json data"
    show_preview "$room"
    echo "  $room's room was fetched ($finalg). Enjoy!"
    ask_to_play "$room"
}

# Remove leading and trailing spaces
# '$1' string var
trim_string() {
    local var
    var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    # Use printf instead of echo, due to possible false parameters in echo
    # e.g. if user enters '-e' option on 'room-status'
    # echo interprets 'var' expansion as parameter: echo "$var" --> echo "-e"
    # See echo manual
    printf '%s' "$var"
}

# Verify that '$1' only contains letters, numbers, spaces, and '/' '.' '_' '-' symbols
# '$1' command string
valid_command_string () {
    [[ "$1" =~ ^[a-zA-Z0-9\ \/\._-]+$ ]]
}

# Show room status: public, private, hidden, away, or offline
internal_status () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    local is_status
    if [[ "$2" == "-e" ]]; then
        assert_active_room "$1" is_status
    else
        is_status="$(fetch_room_status "$1")"
        [[ $? -eq $GET_ERROR ]] && send_exit_error $GET_ERROR
    fi
    echo -n "$1 status: "
    echo "$is_status"
}

# Discard invalid usernames from FAVORITES_FILE
check_favorites () {
    local rline
    while IFS='' read -r rline; do
        valid_username "$rline" && echo "$rline"
    done < "$FAVORITES_FILE" > "${FAVORITES_FILE}.checked"
    sort -u "$FAVORITES_FILE.checked" > "$FAVORITES_FILE"
    rm "${FAVORITES_FILE}.checked"
}

# Open previews on MORE_PDIR
open_more_dir () {
    empty_dir "${MORE_PDIR}/" && send_exit_error $FILESYS_ERROR "${MORE_PDIR}/ directory is empty"
    if [[ $OPEN_ENTIRE_DIR -eq 1 ]]; then
        $VIEWER "$MORE_PDIR"
    else
        local mfiles
        # shellcheck disable=SC2206
        # Quote to prevent word splitting/globbing,
        # or split robustly with mapfile or read -a:
        #read -r -a array <<< "$var"
        mfiles=($MORE_PDIR/*)
        $VIEWER "${mfiles[0]}"
    fi
}

# Remove previews on MORE_PDIR
clear_more_dir () {
    if rm -f "${MORE_PDIR:?}"/*; then
        echo -n "  "; echo "Old content of directory MORE deleted!"
    else
        echo -n "  "; echo "An ${RED_FG}error${CLEAR_FG} occurred while clearing MORE!"
    fi
}

# Fetch rooms list similar to '$1' and save on $MORE_FILE
# '$1' room
fetch_morelist_file () {
    curl -sL --compressed -H "$XRW_HEADER" "${MORELIST_PURL}/$1" -o "$MORE_FILE"
}

# Fetch and show rooms similar to '$1'
# '$1' username
fetch_more_rooms () {
    valid_username "$1" || send_exit_error $VALUE_ERROR "invalid username $1"
    assert_active_room "$1"
    echo "Fetching more rooms like $1 ..."
    fetch_morelist_file "$1" || send_exit_error $GET_ERROR "room list"
    echo "$1" > "$MOREWHO_FILE"
    show_fetch_message
    fetch_rooms_using "$MORE_FILE" "$JQ_MLIST_MAIN" "$JQ_MLIST_USER" clear_more_dir open_more_dir
}

# Send exit error when MOREWHO_FILE does not found
assert_more_who () {
    [[ -e "$MOREWHO_FILE" ]] || send_exit_error $FILESYS_ERROR "file '$MOREWHO_FILE' was not found\n\
Re-run '$mybasename fetch-more username'."
}

# Use favorites
# Ask the user for a choice and play
# '$1' hide_list
play_favorite_choice () {
    local pfc_choice
    favorite_room_choice pfc_choice "${1:-show_list}" play
    play_room "$pfc_choice"
}

# Use other rooms
# Ask the user for a choice and play
# '$1' hide_list
play_other_choice () {
    local poc_choice
    other_room_choice poc_choice "${1:-show_list}" play
    play_room "$poc_choice"
}

# Use more like rooms
# Ask the user for a choice and play
# '$1' hide_list
play_more_choice () {
    local pmc_choice
    more_room_choice pmc_choice "${1:-show_list}" play
    play_room "$pmc_choice"
}

# Show 'More rooms like ...'
more_like_message () {
    assert_more_who
    local whois
    whois="$(cat "$MOREWHO_FILE")"
    valid_username "$whois" || send_exit_error $STORAGE_ERROR "altered username in '$MOREWHO_FILE' file"
    echo "More rooms like '$whois'"
}

# Ask user for multiple choices
# Store an array of numbers on '$1'
# e.g. the user enters " 4 51 3 04    32 0001 " ---> return (4 51 3 4 32 1)
# '$1' to store
# '$2' hide_list
# '$3' custom target (string after "Which room do you want to...")
favorite_multi_choice () {
    declare -n fc_out="$1"
    [[ $2 == "hide_list" ]] || list_favorites -l
    choice_message multi "$3"
    read -r -a fc_out
    [[ "${fc_out[0]}" == [qQ] || -z "${fc_out[0]}" ]] && exit $OK_CODE
    local lcount
    lcount="$(line_count "$FAVORITES_FILE")"
    for i in "${!fc_out[@]}"; do
        valid_id "${fc_out[$i]}" || send_exit_error $VALUE_ERROR "non-numeric choice ${fc_out[$i]}"
        fc_out[i]="$(remove_leading_zeros "${fc_out[$i]}")"
        [[ "${fc_out[$i]}" -lt 1 ]] && send_exit_error $VALUE_ERROR "choice ${fc_out[$i]} is out of range"
        [[ "${fc_out[$i]}" -gt "$lcount" ]] && send_exit_error $VALUE_ERROR "choice ${fc_out[$i]} is out of range"
    done
}

# Ask user for favorites to remove
multi_remove () {
    echo "Multi remove ..."
    local br_choices
    favorite_multi_choice br_choices show_list remove

    # Sort (reverse -r) and keep unique (-u) numbers (-n).
    # Using here-string ( <<< ), process substitution ( <(command) ), and
    # output redirection ( < ). Finally store in array with readarray
    # readarray -t br_choices < <(IFS=$'\n'; sort -run <<<"${br_choices[*]}")
    sort_array br_choices true true true

    echo "You are about to delete:"
    for c in "${br_choices[@]}"; do
        echo -n "  "; get_favorite_line "$c"
    done
    echo -en "${YELLOW_FG}==>${CLEAR_FG} Confirm? (Y/n): "
    read -r rvar
    [[ $rvar == [yY] || $rvar == [yY][eE][sS] || -z $rvar ]] || exit $OK_CODE
    # Remove by line number.
    for c in "${br_choices[@]}"; do
        rem_favorite_line "$c" >/dev/null
    done
    echo "Done, ${#br_choices[@]} favorite(s) removed!"
}

# Check connection to CB main page
connection_check () {
    [[ $CHECK_CONNECTION -eq 0 ]] && return
    echo "Checking connection ..."
    ping -c 1 "${CB_ROOT_PURL##*/}" &>/dev/null || send_exit_error $CONNECTION_ERROR
}

# Get 'n' top tags
# '$1' n
curl_top_tags () {
    curl -sL --compressed -H "$XRW_HEADER" "${TOP_TAGS_PURL}/?count=$1"
}

# Get and show 'n' top tags
# '$1' n
top_hashtags () {
    valid_fetch_digits "$1" || send_exit_error $VALUE_ERROR "invalid value $1"
    local count
    count="$(remove_leading_zeros "$1")"
    [[ $count -gt 0 ]] || send_exit_error $VALUE_ERROR "the value must be greater than 0"
    curl_top_tags "$count" | jq -M .all_tags || send_exit_error $PROCESSING_ERROR "json data"
}

command="$1"
[[ -n "$command" ]] && command="$(trim_string "$command")"

if [[ "$command" == "__favorites_file" ]]; then
    echo "$FAVORITES_FILE"
    exit $OK_CODE
fi

show_dist_warning

if [[ "$command" == "h" || "$command" == "help" ]]; then
    show_help
    exit $OK_CODE
fi

# __clear_* switch/case
case "$command" in
    __clear_favorites)
        clear_favorites_dir
        exit
        ;;
    __clear_captures)
        clear_captures_dir
        exit
        ;;
    __clear_streams)
        clear_streams_dir
        exit
        ;;
    __clear_others)
        clear_others_dir
        exit
        ;;
    __clear_more)
        clear_more_dir
        exit
        ;;
    __clear_all)
        clear_favorites_dir &&
            clear_captures_dir &&
            clear_streams_dir &&
            clear_others_dir &&
            clear_more_dir
        exit
        ;;
esac

param="$2"
[[ -n "$param" ]] && param="$(trim_string "$param")"

if [[ "$command" == "__is_online" ]]; then
    valid_username "$param" || send_exit_error $VALUE_ERROR "invalid username $param"
    alt_is_online "$param"
    # When exit without error code, the value shall be the exit value of the
    # last command executed.
    exit
fi

if [[ "$command" == "__extract_playlist" ]]; then # debug proposes
    [[ -z $param ]] && favorite_room_choice param
    valid_username "$param" || send_exit_error $VALUE_ERROR "invalid username $param"
    __ep=""
    extract_playlist "$param" __ep
    echo "$__ep"
    exit
fi

# Make directories
#[[ -d "$MYPATH" ]] || mkdir -p "$MYPATH"
[[ -d "$DOWNLOADS_PDIR" ]] || mkdir -p "$DOWNLOADS_PDIR"
[[ -d "$STREAMS_PDIR" ]] || mkdir -p "$STREAMS_PDIR"
[[ -d "$CAPTURES_PDIR" ]] || mkdir -p "$CAPTURES_PDIR"
[[ -d "$FAVORITES_PDIR" ]] || mkdir -p "$FAVORITES_PDIR"
[[ -d "$OTHERS_PDIR" ]] || mkdir -p "$OTHERS_PDIR"
[[ -d "$MORE_PDIR" ]] || mkdir -p "$MORE_PDIR"
[[ -e "$FAVORITES_FILE" ]] || touch "$FAVORITES_FILE"

check_favorites
configure

# Main switch
case "$command" in
    a|add)
        connection_check
        show_add_suggestion
        # discard "command" parameter
        shift
        declare -a parr
        # Trim all params
        for p in "$@"; do
            if [[ "$p" == "-f" ]]; then
                fparam="-f"
            else
                parr+=("$(trim_string "$p")")
            fi
        done
        # pass all params
        add_rooms "$fparam" "${parr[@]}"
        ;;
    r|remove)
        remove_room "$param"
        ;;
    R|multi-remove)
        multi_remove
        ;;
    ff|fetch-favorites)
        connection_check
        fetch_favorite_rooms "$param"
        play_favorite_choice hide_list
        ;;
    vf|view-favorites)
        open_favorites_dir
        connection_check
        play_favorite_choice
        ;;
    lf|list-favorites)
        # discard "command" parameter
        shift
        # search '-s', '-l' params, or combinations
        for p in "$@"; do
            [[ "$p" == "-s" ]] && sparam="$p"
            [[ "$p" == "-l" ]] && lparam="$p"
            [[ "$p" == "-sl" || "$p" == "-ls" ]] && lparam="-l" && sparam="-s"
        done
        [[ -n "$sparam" ]] && connection_check
        list_favorites "$sparam" "$lparam"
        ;;
    rs|room-status)
        connection_check
        # discard "param" variable
        unset param
        # discard "command" parameter
        shift
        # search '-e' param, and use the last parameter found as room
        for e in "$@"; do
            if [[ "$e" == "-e" ]]; then
                eparam="-e"
            else
                param="$e"
            fi
        done
        param="$(trim_string "$param")"
        [[ -z "$param" ]] && favorite_room_choice param
        internal_status "$param" "$eparam"
        ;;
    rp|room-programs)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        room_programs "$param"
        ;;
    ri|room-info)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        room_info "$param"
        ;;
    rb|room-bio)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        room_bio "$param"
        ;;
    fo|fetch-others)
        connection_check
        # discard "command" parameter
        shift
        while [[ "$#" -gt 0 ]]; do
            case "$1" in
                -o)
                    [[ -z "$2" ]] && send_exit_error $VALUE_ERROR "missing $1 value"
                    oparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -l)
                    [[ -z "$2" ]] && send_exit_error $VALUE_ERROR "missing $1 value"
                    lparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -g)
                    [[ -z "$2" ]] && send_exit_error $VALUE_ERROR "missing $1 value"
                    gparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -f)
                    [[ -z "$2" ]] && send_exit_error $VALUE_ERROR "missing $1 value"
                    fparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -t)
                    [[ -z "$2" ]] && send_exit_error $VALUE_ERROR "missing $1 value"
                    tparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -r)
                    [[ -z "$2" ]] && send_exit_error $VALUE_ERROR "missing $1 value"
                    rparam="$(trim_string "$2")"
                    shift 2
                    ;;
                -h)
                    [[ -z "$2" ]] && send_exit_error $VALUE_ERROR "missing $1 value"
                    hparam="$(trim_string "$2")"
                    shift 2
                    ;;
                *)
                    send_exit_error $VALUE_ERROR "invalid parameter $1"
                    ;;
            esac
        done
        fetch_other_rooms "$oparam" "$lparam" "$gparam" "$fparam" "$tparam" "$rparam" "$hparam"
        play_other_choice hide_list
        ;;
    vo|view-others)
        open_others_dir
        connection_check
        play_other_choice
        ;;
    lo|list-others)
        list_others
        ;;
    fm|fetch-more)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        fetch_more_rooms "$param"
        play_more_choice hide_list
        ;;
    vm|view-more)
        more_like_message
        open_more_dir
        connection_check
        play_more_choice
        ;;
    lm|list-more)
        more_like_message
        list_more
        ;;
    sc|save-capture)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        save_capture "$param"
        ;;
    ss|save-stream)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        save_room "$param"
        ;;
    ps|play-stream)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        play_room "$param"
        ;;
    ks|keyword-search)
        connection_check
        keyword_search "$param"
        ;;
    th|top-hashtags)
        connection_check
        top_hashtags "$param"
        ;;
    ra|random)
        connection_check
        quick_rand "$param"
        ;;
    tn|thumbnail)
        connection_check
        [[ -z $param ]] && favorite_room_choice param
        quick_thumb "$param"
        ;;
    __check_deps)
        check_dependencies
        ;;
    *)
        send_exit_error $VALUE_ERROR "command $command not found\nUse '$mybasename help' for more info."
        ;;
esac
